---
title: "Multivariate analyses of community structure (classical)"
date: "2018-11-14"
output: 
 html_notebook: 
   theme: paper
---

This notebook contains all (classical) multivariate analyses of zoobenthic community structure: MDS, envfit, ANOSIM & SIMPER and friends.  
All my notebooks are intended to be as self-contained as possible, so there will be a relatively repetitive setup/data import/preparation part.  

***  

Setup!
```{r setup, include = FALSE}
library(knitr)

knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(2, 2, .1, 2))  # smaller margin on top
})

## set the working directory to one up (all notebooks - kept in their own subdirectory within the project directory).
opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

## set knitr options for knitting code into the report.
opts_chunk$set(cache = TRUE, # save results so that code blocks aren't re-run unless code changes
               autodep = TRUE, # ..or unless a relevant earlier code block changed
               cache.comments = FALSE, # don't re-run if the only thing that changed was the comments
               highlight = TRUE, 
               small.mar = TRUE)
```

Define the working subdirectories.  
```{r workspace_setup}
## print the working directory, just to be on the safe side
paste("You are here: ", getwd())

data.dir <- "data"    ## input data files
functions.dir <- "R"  ## functions & scripts
save.dir <- "output"  ## clean data, output from models & more complex calculations
figures.dir <- "figs" ## plots & figures 
```

Import libraries.  
```{r import_packages, results = FALSE}
library(here) ## painless relative paths to subdurectories, etc.
library(tidyverse) ## data manipulation, cleaning, aggregation
library(viridis) ## smart & pretty colour schemes
library(vegan) ## functions for multivariate analyses in ecology 
```

Organize some commonly-used ggplot2 modifications into a more convenient (and less repetitive) format. One day, I MUST figure out the proper way to set the theme..    
```{r custom_ggplot_settings_helpers}
## ggplot settings & things that I keep reusing
# ggplot_theme <- list(
#   theme_bw(),
#   theme(element_text(family = "Times"))
# )

## always use black-and-white theme
theme_set(theme_bw())

## helper to adjust ggplot text size & avoid repetitions 
text_size <- function(text.x = NULL,
                      text.y = NULL,
                      title.x = NULL,
                      title.y = NULL,
                      legend.text = NULL,
                      legend.title = NULL, 
                      strip.x = NULL, 
                      strip.y = NULL) {
  theme(axis.text.x = element_text(size = text.x),
        axis.text.y = element_text(size = text.y),
        axis.title.x = element_text(size = title.x),
        axis.title.y = element_text(size = title.y),
        legend.text = element_text(size = legend.text), 
        legend.title = element_text(size = legend.title), 
        strip.text.x = element_text(size = strip.x), 
        strip.text.y = element_text(size = strip.y)
        )
}

```

Import some custom functions for MDS, envfit and ordisurf plotting in ggplot (or just plain easier and prettier plotting).  
```{r import_custom_functions}
source(here(functions.dir, "plot_mds_revised.R")) ## plot MDS in ggplot; extract envfit scores and overlay on MDS plot in ggplot
source(here(functions.dir, "p_adjust_envfit.R")) ## apply Bonferroni correction for multiple comparisons on envfit results - adjusted p-values
source(here(functions.dir, "plot_ordisurf.R")) ## extract ordisurf scores; plot ordisurf in base R
source(here(functions.dir, "simper_within_group_2.R")) ## SIMPER for within-group species contributions
```

***  

#### **Sand stations (Burgas Bay, 2013-2014)**  
Import zoobenthic abundance data (cleaned and prepared).  
```{r import_zoo_abnd_sand}
zoo.abnd.sand <- read_csv(here(save.dir, "abnd_sand_orig_clean.csv"))

## convert station to factor (better safe than sorry later, when the stations are not plotted in the order I want them)
(zoo.abnd.sand <- zoo.abnd.sand %>% 
    mutate(station = factor(station, levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva")))
)
```

##### **Ordination (nMDS) on sand stations.**  
These are all functions from library vegan.  
```{r mds_zoo_sand}
## the vegan MDS function transforms the data (fourth root) and applies Bray-Curtis dissimilarity by default.   
mds.sand <- metaMDS(zoo.abnd.sand %>% select(-c(station:replicate)), 
                    distance = "bray", 
                    autotransform = TRUE)

mds.sand
```

Examine the quality of the MDS representation..  
```{r mds_quality_sand}
## stressplot
stressplot(mds.sand)

## goodness-of-fit plot 

## first plot the nMDS ordination with sites
plot(mds.sand, display = 'sites', type = 't', main = 'Goodness of fit') 

## then, add the points with size reflecting goodness of fit (smaller = better fit)
points(mds.sand, display = 'sites', cex = goodness(mds.sand)*200) 

```

Well it's not perfect, but could be lived with.. Let's call it good enough.  
The stress is 0.16, which is fairly close to, but still below the limit (0.2) suggested in the Primer manual. 
Save the MDS for the sand stations.  
```{r save_mds_sand}
write_rds(mds.sand, 
          here(save.dir, "mds_sand.RDS"))
```

Now, let's make a pretty plot in ggplot..  
Previously, I had written a custom MDS plotting function for ggplot, which I'm going to review and optimize now (in another notebook kept especially for that).. 
```{r plot_mds_sand}
## plot the MDS, using my custom ggplot function
plot.mds.sand <- plot_mds(mds.sand, groups = zoo.abnd.sand %>% pull(station))

## change colour scheme & labels
(plot.mds.sand <- plot.mds.sand + 
    scale_color_brewer(palette = "Set2", name = "station", 
                       labels = paste0("S", as.numeric((unique(zoo.abnd.sand %>% pull(station))))))
)
```

Well, to me at least it appears that there are **4 groups** on the MDS: 1 - combining stations Kraimorie and Chukalya; 2 - Akin, 3 - Agalina, 4 - combining Sozopol and Paraskeva (although this last one is a bit loosely associated).  
To confirm this, the classical method is to test the observed grouping with ANOSIM. Another more visual test is to overlay a classification tree made with the same data on the ordination, but I don't think I'll bother with it.   

A more statistical approach to determine the optimal number of clusters is to also run **cluster analysis (via k-means clustering)** on the abundance data.
```{r kmeans_sand} 
## with Hellinger transformation of the data (because k-means uses Euclidean distances which don't work well for ecological data).
kmeans.casc.sand <- cascadeKM(decostand(zoo.abnd.sand %>% select(-c(station:replicate)),
                                        method = "hellinger"),
                              inf.gr = 3, sup.gr = 6) ## I want at least 3 groups and at most 6 (the number of stations)

plot(kmeans.casc.sand, sortg = TRUE)
```

This result suggests 5 groups (based on the highest value of the Calinski criterion - plot on the right), but 4 groups is not much worse.. It seems more logical to use 4, because of the oridnation results: 1) S3-Akin + 2) S1-Kraimorie-S2-Chukalya + 3) S5-Agalina + 4) S4-Sozopol-S6-Paraskeva.  
Get these clusters - we'll check them later for validity & relationship with the explanatory environmental variables.   
```{r kmeans_clusters_sand}
## get the partition in 4 groups 
(kmeans.clusters.sand <- as.vector(kmeans.casc.sand$partition[, 2]))
```
OK, the stations' communities are distinct enough that the k-means algorithm separates them well and as expected, so I'm using it..  

##### **Envfit - sand stations.**   
Envfit can be used to determine which environmental parameters correlate best with the ordination (and thus explain best the observed dissimilarities in the zoobenthic community structure between stations).  
As per the PCA results, from the water column parameters, I'll use the most significant ones (best correlated with PCA axes): LUSI, secchi, seston, PO4, NH4, NO3 + all sediment parameters (except the most inter-correlated): TOM, moisture content, gravel and silt_clay.  
First, import the environmental parameters (from the cleaned files).  
For the water column, I'll use the long-term means wherever possible (and repeat each value 9 times per station to match the number of zoobenthic replicates that I have).   
```{r import_water_data_sand}
water.sand.all <- read_csv(here(save.dir, "water_column_summary_LT.csv"))

(water.sand <- water.sand.all %>% 
    ## filter only the sand stations
    filter(station %in% c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva")) %>% 
    
    ## get only the variables we want (significant in PCA)
    select(station, NH4_mean, NO3_mean, PO4_mean, seston_mean, secchi_mean) %>% 
    
    ## remove "mean" from the column names, purely for cosmetics
    rename_at(vars(-station), 
              funs(gsub(pattern = "_mean", replacement =  "", x = .)))
)
```

Now import LUSI and add it to this tibble.  
```{r import_lusi_sand}
lusi <- read_csv(here(save.dir, "lusi_st.csv"))

## only get LUSI for the sand stations and make a new tibble with all environmental data 
(env.data.sand <- inner_join(water.sand,
                             lusi %>% select(-watershed),
                             by = "station")
)
```
Repeat each row 9 times to match the zoobenthic community data (stupid, but needs to be done).  
```{r duplicate_rows_env_data_sand}
(env.data.sand <- env.data.sand %>% 
   slice(rep(1:n(), each = 9))
)
```

Goody! On to the sediment data.  
```{r import_sediments_sand}
sediments.all <- read_csv(here(save.dir, "sediments_imputed_sand.csv"))

(sediments.sand <- sediments.all %>% 
    ## select only the desired subset of variables (reduced list for PCA)
    select(station, TOM, moisture_content, gravel, silt_clay) %>% 
    
    ## repeat each row 3 times (there are 3 distinct values for the sediments, because there were 3 samplings)
    slice(rep(1:n(), each = 3))
)
```

Merge the sediment tibble with the rest of the environmental data.  
```{r merge_env_data_sand}
(env.data.sand <- bind_cols(env.data.sand,
                            sediments.sand %>% select(-station)) %>% 
   ## convert station to factor
   mutate(station = factor(station, levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva")))
)
```

All right, ready to roll!  
Envfit of all this shit & the sand MDS..  
```{r envfit_sand}
envfit.sand <- envfit(mds.sand,
                      env.data.sand %>% select(-station))

## apply the p-value correction.. 
(envfit.sand.adj <- p_adjust_envfit(envfit.sand)
)

## save it for posterity
write_rds(envfit.sand.adj, 
          here(save.dir, "envfit_sand_adj.RDS"))
```

Plot the envfit vectors over the MDS of the sand stations.  
```{r plot_envfit_sand}
## extract the envfit scores - easier format for plotting in ggplot.. 
(envfit.scrs.sand <- extract_envfit_scores(envfit.sand.adj, pval = 0.05)
)

## plot over the ordination 
(plot.envfit.sand <- plot_envfit(plot.mds.sand,
                                 envfit.scrs.sand,
                                 param.labels = param,
                                 label.col = "grey35")
)

## save plot
ggsave(here(figures.dir, "mds_envfit_sand.png"), 
       plot.envfit.sand,      
       width = 15, units = "cm", dpi = 300)
```

##### **Ordisurf - sand stations.**   
Since most environmental parameters don't vary linearly, especially in the marine environment, it's better to fit **surfaces** over the ordination (using a GAM) rather than vectors. There's a function for that in package vegan - ordisurf.  
First, get the environmental data we want (significant variables from envfit, p < 0.05).   
```{r ordisurf_data_sand}
(env.data.ordi.sand <- env.data.sand %>% 
   select(envfit.scrs.sand %>% pull(param))
)
```

Apply ordisurf sequentially to all these variables (keep results in a list).  
```{r ordisurf_sand_all}
## perform ordisurf on all variables in a loop
(ordi.list.all.sand <- apply(env.data.ordi.sand, MARGIN = 2, 
                             FUN = function(x) ordisurf(mds.sand ~ x, plot = FALSE))
)

## save this
write_rds(ordi.list.all.sand, 
          here(save.dir, "ordisurf_all_sand.RDS"))
```

Plot all ordisurfs in one go - with one monstrous mapply call, because I want plot titles, too. Not sure if I'll bother with renaming the ordisurf list so that the titles are more legible/suitable for direct use in the thesis text.  
```{r plot_ordisurf_sand_all}
mapply(function(x, y) {
    ## construct the file name 
    plot.name <- paste0("ordisurf_sand_", x, ".png")
    
    ## open png graphical device - we're working with base graphics
    png(here(figures.dir, plot.name), width = 1000, height = 1000, res = 200)
    
    ## plot ordisurf using my pretty custom function
    plot_mds_ordisurf(mds.sand, y)
    
    ## add a title
    title(main = x, col.main = "grey30", cex.main = 0.9, line = 0.5)
    
    ## close the graphics device
    dev.off()
}, 
names(ordi.list.all.sand), 
ordi.list.all.sand, 
SIMPLIFY = FALSE)

```

Plot all of the variables/ordisurfs on one big plot - very fiddly, lots of guesswork with base graphics! 
```{r plot_ordisurf_sand_all_composite}
## open png graphics device
png(here(figures.dir, "ordisurf_all_composite_sand"), width = 2000, height = 2000, res = 200)

## divide the plotting space - manually, knowing the number of subplots that will have to be fitted on one page
par(mfrow = c(3, 3))

## plot!
mapply(function(x, y) {
    ## plot ordisurf using my pretty custom function
    plot_mds_ordisurf(mds.sand, y)
    
    ## add a title
    title(main = x, col.main = "grey30", cex.main = 1, line = 0.5)
}, 
names(ordi.list.all.sand), 
ordi.list.all.sand, 
SIMPLIFY = FALSE)

## close the current graphics device, writing the file to disk
dev.off()

## return the plotting device settings to normal
par(mfrow = c(1, 1))
```

The observed MDS grouping is described 1) by the eutrophication/anthropogenic pressure gradient (water column parameters + LUSI), but also 2) by the sediment parameters - grain size & organic matter. That's why S5-Agalina is separate from the others - it has coarser sediments (more gravel) + organic matter because it's close to a natural reef, but it's in the outer bay - so less nutrients and more transparent water. That's why its community structure is also very distinct.  
This grouping should be confirmed through ANOSIM, and if deemed valid - SIMPER to see which the distinctive species are.  

##### **ANOSIM - sand stations.**   
This is a non-parametric permutation procedure applied to the rank (similarity) matrix underlying the ordination or classification of the samples.  
R statistic: -1 to 1; 1 = all replicates within sites are more similar to each other than to any other replicate from a different site; 0 = H0 is true (the same average similarities between and within sites). Usually 0 < R < 1 => some degree of difference observed between sites.  
Best course of analysis: 1) global ANOSIM - overall difference between groups; if significant - 2) where does the main between-group difference come from?  
=> examine R values for each pairwise comparison: large = complete separation, small - little or no difference.  
NB ANOSIM doesn’t really have much statistical power and tends to get confounded by higher variances!..  

Let's try grouping by the apparent MDS clusters.  
```{r anosim_mds_clusters_sand}
anosim.kmeans.sand <- anosim(zoo.abnd.sand %>% 
                               select(-c(station:replicate)) %>%
                               mutate_all(sqrt),
                             grouping = kmeans.clusters.sand)

summary(anosim.kmeans.sand)
```
So the grouping is highly significant, while within-group variation is very small, for all it's worth given ANOSIM's properties..  
Probably worthless, but - better safe than sorry; save this ANOSIM.  
```{r save_anosim_mds_clusters_sand}
write_rds(anosim.kmeans.sand, 
          here(save.dir, "anosim_mds_clusters_sand.RDS"))
```


##### **SIMPER - sand stations**   
This is another one of the confused-by-high variances distance-based methods
First - check the species contributions to the **between-group variance**, using the same groups as before (MDS clusters).  
```{r simper_bn_group_mds_clusters_sand}
simper.bn.gr.sand <- simper(zoo.abnd.sand %>% 
                              select(-c(station:replicate)) %>%
                              mutate_all(sqrt),
                            group = kmeans.clusters.sand)

simper.bn.gr.sand

```

Goody.. The summary output is about 3 km long, so I'm not printing it out.  
Save!  
```{r save_simper_bn_group_mds_clusters_sand}
write_rds(simper.bn.gr.sand, 
          here(save.dir, "simper_bn_group_mds_clusters_sand.RDS"))
```

Now, the within-group SIMPER (which species are the most characteristic of each group) - custom function, because vegan doesn't provide this option, with good reason..   
```{r simper_wn_group_mds_clusters_sand}
simper.wn.gr.sand <- simper_within_group(zoo.abnd.sand %>%
                                           select(-c(station:replicate)),
                                         group = kmeans.clusters.sand)

simper.wn.gr.sand

```

So most group similarities are around 60%. Group 1 (S4-S6) has the lowest - 48.7%. It's not very surprising; if you look at the MDS, these samples are more dispersed - there is some variation in community composition, but I'm still inclined to consider it a single group because of the sediment composition, the depth and the community dominants.  
According to the Bulgarian national classification, the stations fall into the following biotopes:  
* group 1 (S4-S6): “Infralittoral fine and medium sand dominated by *Chamelea gallina*, *Lentidium mediterraneum* and *Tellina tenuis*” (ILitFSCham). Only *C. gallina* is singled out by the within-group SIMPER, thanks to its dominance in the samples.. The other species are really minor, seen in only a few of the samples and only as a few individuals. So, SIMPER really does focus on species with large variance, and not necessarily on characterstic ones.  
* group 2 (S5): I'm calling it “Infralittoral mixed sediments with diverse fauna” (ILitMSVar) - not really one of the national subtypes - since many species have significant and really close contributions to the community composition. The dominants are *Microdeutopus versiculatus*, *Protodorvillea kefersteini*, *Melita palmata*, *Eurydice dollfusi*, etc. It really is pretty unique in composition - the closest would be S3, but the sediment composition distingishes it enough..  
* group 3 (S1-S2): “Infralittoral sandy muds dominated by *Melinna palmata*, *Anadara kagoshimensis*, *Heteromastus filiformis*” (ILitMMelin). It's not one of the national biotopes, either. Dominants according to SIMPER: *H. filiformis*, Oligochaeta, *M. palmata*, *Prionospio cirrifera*, *A. kagoshimensis*. 
* group 4 (S3): this corresponds most closely to the subtype “Infralittoral medium and coarse sands dominated by *Upogebia pusilla*” (ILitCSUpog) (even though *U.pusilla* itself is absent from the samples). Dominants: *Protodorvillea kefersteini*, Oligochaeta, *Branchiostoma lanceolatum*, *Ophelia limacina*, *Chamelea gallina*.  

Save this SIMPER! 
```{r save_simper_wn_gr_mds_clusters_sand}
write_rds(simper.wn.gr.sand, 
          here(save.dir, "simper_wn_group_mds_clusters_sand.RDS"))
```

For the fun of it, let's plot the MDS again, with biotope labels on top of each group.   
```{r plot_mds_sand_biotopes}
## extract and calculate the centroids (mean coordinates) of the ellipses to use for label placement
(biotope.labs.sand <- as_data_frame(scores(mds.sand, display = "sites")) %>%
   mutate(biotope = kmeans.clusters.sand) %>% 
   ## calculate the centroids for the labels
   group_by(biotope) %>%
   summarize_all(mean) %>% 
   ## add text labels
   mutate(lab = case_when(biotope == 1 ~ "ILitFSCham", 
                          biotope == 2 ~ "ILitMSVar", 
                          biotope == 3 ~ "ILitMMelin", 
                          biotope == 4 ~ "ILitCSUpog"))
)


plot_mds(mds.sand, groups = kmeans.clusters.sand) +
  stat_ellipse(aes(group = kmeans.clusters.sand), lwd = 0.2) +
  geom_text(data = biotope.labs.sand,
            aes(x = NMDS1, y = NMDS2, group = biotope, label = lab),  
            inherit.aes = FALSE) + 
  theme(legend.position = "none")

```

Finally, I'll do an MDS only on group 1 (S4-S6), to see if there really is grounds to divide it into 2 separate groups.  
```{r mds_group1_sand}
## subset only these stations 
mds.sand.gr1 <- metaMDS(zoo.abnd.sand %>% 
                          filter(station %in% c("Sozopol", "Paraskeva")) %>% 
                          select(-c(station:replicate)))

mds.sand.gr1

plot_mds(mds.sand.gr1)
```

I don't really see any sort of groups, even though the MDS is significant. I'm not going to subdivide this group after all.  

##### **PERMANOVA - environmental parameters, sand stations**  
This is multivariate ANOVA based on dissimilarities (in package vegan - function adonis).  
From the help file: used for partitioning distance matrices among sources of variation and fitting linear models (e.g., factors, polynomial regression) to distance matrices; uses a permutation test with pseudo-F ratios.  

Make a distance matrix of the communities, and check multivariate homogeneity of groups dispersions (variances) - a PERMANOVA assumption.  
```{r check_permanova_assumptions_sand}
## make distance matrix of the sand communities (square root transformed)
dist.matrix.sand <- vegdist(zoo.abnd.sand %>% 
                              select(-c(station:replicate)) %>%
                              mutate_all(sqrt))

## check the dispersion between groups - using the clusters from the MDS
(betadisper.sand <- betadisper(dist.matrix.sand, 
                               group = kmeans.clusters.sand)
)

anova(betadisper.sand)

```

So there are significant differences in dispersion between groups that might also contribute to any significant effect detected by PERMANOVA.. 

Have to decide whether it makes sense to stratify by groups/clusters, or no need.. 
```{r permanova_env_params_sand}
## construct equation for PERMANOVA
permanova.eq.sand <- paste("dist.matrix.sand", 
                           paste(names(env.data.ordi.sand), collapse = "+"), 
                           sep = " ~ ")

## set blocks for the permutations
permutations.sand <- how(nperm = 999)
setBlocks(permutations.sand) <- kmeans.clusters.sand
 
## run the PERMANOVA with the parameters defined above  
(permanova.env.sand <- adonis(as.formula(permanova.eq.sand),
                              data = env.data.ordi.sand, 
                              permutations = permutations.sand)
)
```

Well, this looks more or less plausible..  
The analysis singles out NH4, PO4, seston, secchi, and silt-clay content as the most significant environmental variables, with TOM lagging a bit behind, nearing the limit of significance.  
I'm going to go with it; I just don't have more time for tinkering.  

Save the PERMANOVA results.  
```{r save_permanova_env_params_sand}
write_rds(permanova.env.sand, 
          here(save.dir, "permanova_env_params_sand.RDS"))
```


***  

#### **Seagrass stations (Burgas Bay, 2013-2014)**  
Import zoobenthic abundance data (cleaned and prepared).  
```{r import_zoo_abnd_zostera}
zoo.abnd.zostera <- read_csv(here(save.dir, "abnd_zostera_orig_clean.csv"))

## convert station to factor (better safe than sorry later, when the stations are not plotted in the order I want them)
(zoo.abnd.zostera <- zoo.abnd.zostera %>% 
    mutate(station = factor(station, levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo")))
)
```

##### **Ordination (nMDS) on seagrass stations.**  
These are all functions from library vegan.  
```{r mds_zoo_zostera}
## the vegan MDS function transforms the data (fourth root) and applies Bray-Curtis dissimilarity by default.   
mds.zostera <- metaMDS(zoo.abnd.zostera %>% select(-c(station:replicate)), 
                       distance = "bray", 
                       autotransform = TRUE)

mds.zostera
```

Examine the quality of the MDS representation..  
```{r mds_quality_zostera}
## stressplot
stressplot(mds.zostera)

## goodness-of-fit plot 
## first, plot the nMDS ordination with sites
plot(mds.zostera, display = 'sites', type = 't', main = 'Goodness of fit') 

## then, add the points with size reflecting goodness of fit (smaller = better fit)
points(mds.zostera, display = 'sites', cex = goodness(mds.zostera)*200) 

```

This is worse than the sand station MDS, but still within the acceptable bounds (stress = 0.17). Could be better, though..  
Save the MDS for the seagrass stations.  
```{r save_mds_zostera}
write_rds(mds.zostera, 
          here(save.dir, "mds_zostera.RDS"))
```

Make a pretty plot in ggplot..  
```{r plot_mds_zostera}
## plot the MDS, using my custom ggplot function
plot.mds.zostera <- plot_mds(mds.zostera, groups = zoo.abnd.zostera %>% pull(station))

## change colour scheme & labels
(plot.mds.zostera <- plot.mds.zostera + 
    scale_color_brewer(palette = "Set2", name = "station", 
                       labels = paste0("Z", as.numeric((unique(zoo.abnd.zostera %>% pull(station))))))
)
```

OK... they are just not so different - probably could all be considered one biotope, Zostera-associated fauna or something of the sort. There is also variation within each group (station) - especially clear in Z1 and Z2, where there were differences in commnunity composition **between years**. Interestingly, the stations stil form distinctly separate groups - could be due to anthropogenic pressure?  

Let's plot the MDS, but coloured by year this time.  
```{r plot_mds_yrs_zostera}
(plot.mds.yr.zostera <- plot_mds(mds.zostera, 
                                 groups = zoo.abnd.zostera %>% 
                                   mutate(year = factor(year)) %>% 
                                   pull(year)) + 
   theme(legend.title = element_blank())
)

## save, in case I decide to use it.. 
ggsave(here(figures.dir, "mds_yr_zostera.png"), 
       plot.mds.yr.zostera, 
       width = 15, units = "cm", dpi = 300)

```

There really looks to be a difference in community composition between years (of course, for those stations that were sampled 2 times, in 2013 and 2014). By the way it also appears in the biotic index assessments, with an improvement in ecological state in 2014. I don't see much reason for this in the environmental parameters, but then again, the samplings for these were not really systematic, so I can't expect significant results..  

Determine the optimal number of clusters by **cluster analysis (via k-means clustering)** on the abundance data.
```{r kmeans_zostera} 
## with Hellinger transformation of the data (because k-means uses Euclidean distances which don't work well for ecological data).
kmeans.casc.zostera <- cascadeKM(decostand(zoo.abnd.zostera %>% select(-c(station:replicate)),
                                           method = "hellinger"),
                                 inf.gr = 2, sup.gr = 5) ## I want at least 2 groups and at most 5 (the number of stations)

plot(kmeans.casc.zostera, sortg = TRUE)
```

This result suggests 2 or 3 groups, but they cut over each other or something.. Not good.     
Let's go with 2 and get - and check - them. 
```{r kmeans_clusters_zostera}
## get the partition in 3 groups 
(kmeans.clusters.zostera <- as.vector(kmeans.casc.zostera$partition[, 1]))
```
Yeess this algorithm *tries* to separate more or less as by years, but doesn't really manage it, because the stations still have distinct enough communities, and not all were sampled both in 2013 and 2014. 
It doesn't improve much if there are 3, 4 and 5 groups. Check it out on the MDS:     
```{r plot_mds_kmeans_all_zostera}
lapply(colnames(kmeans.casc.zostera$partition), 
       function(x) {
         plot_mds(mds.zostera, groups = factor(as.vector(kmeans.casc.zostera$partition[, x])))
       }
       )

```
So there is a difference in **both stations and years** in seagrass habitats. In hindsight, should have done that check beforehand - like I did for the 2012 stations, to decide if I could aggregate by site instead of by station.. Maybe will go back and do it now.  
Since the k-means clusters are sort of useless (just illogical - the clustering algorithm has no prior knowledge of stations and years and replicates, it just sorts), I'm going with my own groupings - stations & years.  

```{r clusters_zostera}
## station is already a factor
(clusters.st.zostera <- zoo.abnd.zostera %>% pull(station))

## year must be transformed into a factor first
(clusters.yr.zostera <- zoo.abnd.zostera %>% 
    mutate(year = factor(year, levels = c(2013, 2014))) %>% 
    pull(year)
)
```

##### **Envfit - seagrass stations.**   
As per the PCA results, from the water column parameters, I'll use the most significant ones (best correlated with PCA axes): LUSI, chl-a, Ntot, secchi + all sediment parameters (except the most inter-correlated): TOM, moisture content, mean grain size, sand, silt_clay + all seagrass parameters: shoot count, above-ground biomass, below-ground biomass.  

First, import the environmental parameters (from the cleaned files).  
For the water column, I'll use the long-term means wherever possible (and repeat each value to match the number of zoobenthic replicates that I have).   
```{r import_water_data_zostera}
## the long-term summaries of water column data already have the seagrass stations, too
(water.zostera <- water.sand.all %>% 
    ## filter only the zostera stations
    filter(station %in% c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo")) %>% 
    
    ## get only the variables we want (significant in PCA)
    select(station, Ntotal_mean, chl_a_mean, secchi_mean) %>% 
    
    ## remove "mean" from the column names, purely for cosmetics
    rename_at(vars(-station), 
              funs(gsub(pattern = "_mean", replacement =  "", x = .)))
)
```

Add LUSI to this tibble.  
```{r import_lusi_zostera}
## only get LUSI for the zostera stations and make a new tibble with all environmental data 
(env.data.zostera <- inner_join(water.zostera,
                                lusi %>% select(-watershed),
                                by = "station")
)
```
Repeat each row to match the zoobenthic community data (stupid, but needs to be done). **These will not differ by year.**  
```{r duplicate_rows_water_zostera}
## in two iterations: first, for the stations that have 2 samplings (= 8 replicates each)
env.data.zostera.fin <- env.data.zostera %>% 
   filter(station %in% c("Poda", "Otmanli", "Gradina")) %>% 
   slice(rep(1:n(), each = 8))

## second, add the other two stations (= 4 replicates each)
env.data.zostera.fin <- bind_rows(env.data.zostera.fin, 
                                  env.data.zostera %>% 
                                    filter(station %in% c("Vromos", "Ropotamo")) %>% 
                                    slice(rep(1:n(), each = 4)))

## convert station to factor and order by it 
(env.data.zostera.fin <- env.data.zostera.fin %>% 
    mutate(station = factor(station, levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo"))) %>% 
    arrange(station)
)
```

On to the sediment data. Now for this I'm keeping the years.    
```{r import_sediments_zostera}
sediments.zostera <- read_csv(here(save.dir, "sediments_seagrass_raw_clean.csv"))

(sediments.zostera <- sediments.zostera %>% 
    ## select only the desired subset of variables (reduced list for PCA)
    select(station, year, TOM, moisture_content, mean_grain_size, sand, silt_clay) %>% 
        ## convert station to factor & arrange
    mutate(station = factor(station, levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo")), 
           year = factor(year, levels = c(2013, 2014))) %>%
    arrange(station, year) %>% 
    
    ## average them all by station and year
    group_by(station, year) %>% 
    select(-c(station, year)) %>%
    summarize_all(mean)

)
```

Duplicate the sediment data in the same way as before.  
```{r duplicate_rows_sediments_zostera}
(sediments.zostera.fin <- sediments.zostera %>% 
   slice(rep(1:n(), each = 4))
)
```

Import the seagrass parameter data.  
```{r import_seagrass_data_zostera}
(seagrass <- read_csv(here(save.dir, "seagrass_summary_2013_2014.csv"))
)
```

Duplicate the rows - same as the sediments.  
```{r duplicate_rows_seagrass_zostera}
(seagrass.fin <- seagrass %>% 
   ## convert station and year to factor.. 
   mutate(station = factor(station, levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo")), 
          year = factor(year, levels = c(2013, 2014))) %>% 
   
   ## duplicate rows as before
   slice(rep(1:n(), each = 4)) %>% 
   
   ## remove "_mean" from the column names
   rename_at(vars(-c(station, year)), 
             funs(gsub(pattern = "_mean", replacement =  "", x = .)))
)
```

Merge all environmental data tibbles..  
```{r merge_env_data_zostera}
## NB first make sure the sediment and seagrass data are arranged by station and year - as the zoobenthic community data!! 
(env.data.zostera.all <- bind_cols(env.data.zostera.fin,
                                   sediments.zostera.fin %>% ungroup() %>% select(-station),
                                   seagrass.fin %>% select(-c(station, year))
                                   ) %>%
   ## rearrange columns
   select(station, year, everything())
)  
```

Finally, everything seems to be in order..  

Envfit of all this shit and the seagrass MDS.  
```{r envfit_zostera}
envfit.zostera <- envfit(mds.zostera,
                         env.data.zostera.all %>% select(-station), 
                         na.rm = TRUE)

## apply the p-value correction.. 
(envfit.zostera.adj <- p_adjust_envfit(envfit.zostera)
)

## save it for posterity
write_rds(envfit.zostera.adj, 
          here(save.dir, "envfit_zostera_adj.RDS"))
```

Plot the envfit vectors over the MDS of the seagrass stations.  
```{r plot_envfit_zostera}
## extract the envfit scores - easier format for plotting in ggplot 
(envfit.scrs.zostera <- extract_envfit_scores(envfit.zostera.adj, pval = 0.05)
)

## plot over the ordination 
(plot.envfit.zostera <- plot_envfit(plot.mds.zostera,
                                    envfit.scrs.zostera,
                                    param.labels = param,
                                    label.col = "grey35")
)

## save plot
ggsave(here(figures.dir, "mds_envfit_zostera.png"), 
       plot.envfit.zostera,      
       width = 15, units = "cm", dpi = 300)
```

##### **Ordisurf - seagrass stations.**   
First, get the environmental data we want (significant variables from envfit, p < 0.05).   
```{r ordisurf_data_zostera}
(env.data.ordi.zostera <- env.data.zostera.all %>% 
   select(envfit.scrs.zostera %>% pull(param))
)
```

Apply ordisurf sequentially to all these variables (keep results in a list).  
```{r ordisurf_zostera_all}
## perform ordisurf on all variables in a loop
(ordi.list.all.zostera <- apply(env.data.ordi.zostera, MARGIN = 2,
                                FUN = function(x) ordisurf(mds.zostera ~ x, plot = FALSE))
)

## save this
write_rds(ordi.list.all.zostera, 
          here(save.dir, "ordisurf_all_zostera.RDS"))
```

Plot all ordisurfs in one go - with one monstrous mapply call, because I want plot titles, too. Not sure if I'll bother with renaming the ordisurf list so that the titles are more legible/suitable for direct use in the thesis text.  
```{r plot_ordisurf_zostera_all}
mapply(function(x, y) {
    ## construct the file name 
    plot.name <- paste0("ordisurf_zostera_", x, ".png")
    
    ## open png graphical device - we're working with base graphics
    png(here(figures.dir, plot.name), width = 1000, height = 1000, res = 200)
    
    ## plot ordisurf using my pretty custom function
    plot_mds_ordisurf(mds.zostera, y)
    
    ## add a title
    title(main = x, col.main = "grey30", cex.main = 0.9, line = 0.5)
    
    ## close the graphics device
    dev.off()
}, 
names(ordi.list.all.zostera), 
ordi.list.all.zostera, 
SIMPLIFY = FALSE)

```

Plot all of the variables/ordisurfs on one big plot.
```{r plot_ordisurf_zostera_all_composite}
## open png graphics device
png(here(figures.dir, "ordisurf_all_composite_zostera"), width = 2000, height = 2000, res = 200)

## divide the plotting space - manually, knowing the number of subplots that will have to be fitted on one page
par(mfrow = c(2, 3))

## plot!
mapply(function(x, y) {
    ## plot ordisurf using my pretty custom function
    plot_mds_ordisurf(mds.zostera, y)
    
    ## add a title
    title(main = x, col.main = "grey30", cex.main = 1, line = 0.5)
}, 
names(ordi.list.all.zostera), 
ordi.list.all.zostera, 
SIMPLIFY = FALSE)

## close the current graphics device, writing the file to disk
dev.off()

## return the plotting device settings to normal
par(mfrow = c(1, 1))
```

##### **ANOSIM - seagrass stations.**   
This time the grouping will be by station.. because the MDS clusters.  
```{r anosim_mds_clusters_st_zostera}
anosim.st.zostera <- anosim(zoo.abnd.zostera %>% 
                              select(-c(station:replicate)) %>% 
                              mutate_all(sqrt),
                            grouping = clusters.st.zostera)

summary(anosim.st.zostera)

```

The station grouping **is** significant after all, according to ANOSIM. The R value is high, too, so we can probably say that the factor station does influence the grouping.  
Of course, this is all keeping in mind that ANOSIM usage is not advised, as the function is not very robust (see notes in ANOSIM help file in R).  
Save it!  
```{r save_anosim_mds_clusters_st_zostera}
write_rds(anosim.st.zostera, 
          here(save.dir, "anosim_mds_clusters_st_zostera.RDS"))
```


Check the years, to be on the safe side (even though when put in envfit as a factor it's not significant).
```{r anosim_mds_clusters_yr_zostera}
summary(anosim(zoo.abnd.zostera %>% 
                 select(-c(station:replicate)) %>% 
                 mutate_all(sqrt),
               grouping = clusters.yr.zostera))

```

The year grouping is **also** significant, according to ANOSIM; however, the R value is low, < 0.2, so the factor year probably does not really exert very much significance after all.  

##### **SIMPER - seagrass stations**   
First - check the species contributions to the **between-group variance**, using the same groups as before (MDS clusters - stations).  
```{r simper_bn_group_mds_clusters_st_zostera}
simper.bn.gr.zostera <- simper(zoo.abnd.zostera %>%
                                 select(-c(station:replicate)) %>%
                                 mutate_all(sqrt),
                               group = clusters.st.zostera)

simper.bn.gr.zostera

```

I'm still not printing it out in its entirety.   
Save!  
```{r save_simper_bn_group_mds_clusters_st_zostera}
write_rds(simper.bn.gr.zostera, 
          here(save.dir, "simper_bn_group_mds_clusters_st_zostera.RDS"))
```

Now, the within-group SIMPER.   
```{r simper_wn_group_mds_clusters_st_zostera}
simper.wn.gr.zostera <- simper_within_group(zoo.abnd.zostera %>%
                                              select(-c(station:replicate)),
                                            group = clusters.st.zostera)

simper.wn.gr.zostera

```

So, according to SIMPER, the group similarities are around 60-70%. They are highest for Vromos and Ropotamo - could be because there are less samples in these groups and therefore less variability.   
The 5 groups' characteristic (the ones accounting for around 70% of the group similarity) species are:  
* group 1 (Z1-Poda): *Polydora ciliata*, Oligochaeta, *Capitella minima*, *Ampelisca diadema*, *Bittium reticulatum*, *Abra alba*, *Heteromastus filiformis*, *Rissoa membranacea*, *Amphibalanus improvisus*.  
* group 2 (Z2-Otmanli): *Bittium reticulatum*, Oligochaeta, *Heteromastus filiformis*, *Prionospio cirrifera*, *Capitella minima*, *Monocorophium acherusicum*, *Lagis koreni*, *Abra alba*, *Syllis gracilis*,...  
* group 3 (Z3-Vromos): *Ampelisca diadema*, *Capitella minima*, *Monocorophium acherusicum*, *Spio filicornis*, *Rissoa membranacea*, *Platynereis dumerilii*, *Parvicardium exiguum*, *Melinna palmata*.  
* group 4 (Z4-Gradina): *Bittium reticulatum*, *Mytilaster lineatus*, *Heteromastus filiformis*, *Capitella minima*, *Protodorvillea kefersteini*, *Cumella limicola*, *Loripes orbiculatus*, Oligochaeta, *Ampelisca diadema*, *Rissoa membranacea*..   
* group 5 (Z5-Ropotamo): Oligochaeta, *Capitella minima*, *Apseudopsis ostroumovi*, *Bittium reticulatum*, *Capitella capitata*, *Ampelisca diadema*, *Prionospio cirrifera*, *Microdeutopus gryllotalpa*, *Polydora ciliata*, *Salvatoria clavata*...  

Save this SIMPER, too.   
```{r save_simper_wn_gr_mds_clusters_st_zostera}
write_rds(simper.wn.gr.zostera, 
          here(save.dir, "simper_wn_group_mds_clusters_st_zostera.RDS"))
```


---
title: "Environmental parameters - analysis & variable selection"
date: "2018-04-12"
output: 
  html_notebook:
    theme: paper
---
  
Setup!  
```{r setup, include = FALSE}
library(knitr)

knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(2, 2, .1, 2))  # smaller margin on top
})

## set the working directory to one up (all notebooks - kept in their own subdirectory within the project directory).
opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

## set knitr options for knitting code into the report.
opts_chunk$set(cache = TRUE, # save results so that code blocks aren't re-run unless code changes
               autodep = TRUE, # ..or unless a relevant earlier code block changed
               cache.comments = FALSE, # don't re-run if the only thing that changed was the comments
               highlight = TRUE, 
               small.mar = TRUE)
```

Define the working subdirectories.  
```{r workspace_setup}
## print the working directory, just to be on the safe side
paste("You are here: ", getwd())

data.dir <- "data"    # input data files
functions.dir <- "R"  # functions & scripts
save.dir <- "output"  # clean data, output from models & more complex calculations
figures.dir <- "figs" # plots & figures 
```

Import libraries.  
```{r import_packages, results = FALSE}
library(here) # painless relative paths to subdurectories, etc.
library(tidyverse) # data manipulation, cleaning, aggregation
library(viridis) # smart & pretty colour schemes
library(caret) # variable selection, pruning & other wrapper functions for modeling

library(FactoMineR) # PCA
library(factoextra) # visualization & exploration of PCA results
library(FactoInvestigate) # automatic report, visualization & interpretation of PCA results (analyses done with FactoMineR)

# if not installed:
# devtools::install_github("kassambara/factoextra")
# install.packages("FactoMineR", "factoextra")

library(glmnet) # elastic net variable selection & model fitting 
```

Organize some commonly-used ggplot2 modifications into a more convenient (and less repetitive) format.  
```{r custom_ggplot_settings_helpers}
## ggplot settings & things that I keep reusing
# ggplot_theme <- list(
#   theme_bw(),
#   theme(element_text(family = "Times"))
# )

## always use black-and-white theme
theme_set(theme_bw())

## helper to adjust ggplot text size & avoid repetitions 
text_size <- function(text.x = NULL,
                      text.y = NULL,
                      title.x = NULL,
                      title.y = NULL,
                      legend.text = NULL,
                      legend.title = NULL, 
                      strip.x = NULL, 
                      strip.y = NULL) {
  theme(axis.text.x = element_text(size = text.x),
        axis.text.y = element_text(size = text.y),
        axis.title.x = element_text(size = title.x),
        axis.title.y = element_text(size = title.y),
        legend.text = element_text(size = legend.text), 
        legend.title = element_text(size = legend.title), 
        strip.text.x = element_text(size = strip.x), 
        strip.text.y = element_text(size = strip.y)
        )
}

```

***  

This notebook details the analyses & variable selection of the environmental parameters. I'm giving them their own notebook for clarity and simplicity.  
This is a direct continuation of the cleanup & summarization notebook on environmental parameters; I'm going to import some of the summary tibbles produced there directly from the save folder.    
Again, the analyses will proceed in 3 separate datasets: 2012, sand (2013-2014), and seagrass (2013-2014).   
Two lines of analysis will be applied:  
1) PCA - to see which variables best account for the differences between stations. The "winners" will go on to the multivariate analyses attempting to relate community structure to environment.  
PCA will be applied on 3 sets of explanatory variables - water column (+ LUSI), sediments (+ seagrass, where relevant), and heavy metals; y = station (and habitat, in the case of sand). Prior to the PCA, some (feeble) variable selection will be performed - mostly to get rid of highly correlated variables.  
2) Elastic net - another method of variable selection.  
Again, there will be 3 sets of explanatory variables - as above.  
y = categorical (station, habitats) - logistic regression with multinomial models & grouped lasso penalty.  
y = numeric (species abundances) - multi-response Gaussian linear regression with many correlated responses (+ maybe should be applied over a sparse matrix).  

##### Sand stations (Burgas Bay, 2013-2014)  
Import environmental data.   
```{r import_water_data_sand}
## contains the long-term water column parameters, summarized by station. 
water <- read_csv(here(save.dir, "water_column_summary_LT.csv"))

## filter (manually) to get only the sand 2013-2014 stations
(water.sand <- water %>% 
    filter(station %in% c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva"))
)
```

Import the sediment data (it also contains the heavy metals).   
```{r import_sediment_data_sand}
sediments <- read_csv(here(save.dir, "sediments_imputed_sand.csv"))

## split into sediment parameters sesnu stricto, and heavy metals
(sediments.sand <- sediments %>% 
    select(station:year, TOM:silt_clay)
)  

(heavy.metals.sand <- sediments %>% 
    select(station:year, Cu:Ni) 
)
```

Import LUSI and add it to the water column data, although strictly speaking, it isn't really..  
```{r import_lusi_sand}
(lusi <- read_csv(here(save.dir, "lusi_st.csv"))
)

## we'll match them by station - and we only want the sand stations - the rows of x (the water column data) where there are matching values in y (LUSI) -> e.g. inner join 
(water.sand <- inner_join(water.sand, 
                          lusi %>% select(-watershed), 
                          by = "station")
)
```
The nutrients all decrease towards the outer bay, more or less so, and so do the chl-a and suspended matter; the transparency (Secchi depth) increases - this is the long-term (anthropgenic) eutrophication gradient in Burgas Bay, consistent with previous studies (..) & models.   

Now let's check the correlations between water column parameters. More or less important: LUSI is (significantly) positively correlated with most long-term nutrient concentrations, chl-a and suspended matter, and negatively correlated with Secchi depth, which is good - shows that it's a good indicator of the anthropogenic pressure gradient of Burgas Bay. Could maybe be used as a proxy for all of these in the analyses? As a side note, the fact that it doesn't require the analyses of samples upon water samples is also not too shabby.     
```{r water_sand_correlations}
Hmisc::rcorr(as.matrix(water.sand %>% select(-station)), 
             type = "pearson")
```
  
Now we'll proceed with the variable selection for the PCA. For whatever it's worth, I don't think PCA with so few observations can be valid, but hey, all the kids are doing it.    
We'll just eliminate the most inter-correlated variables using package caret.  
```{r filter_correlated_sand}
# calculate the correlation matrix (on the numeric variables only)
water.sand.cors <- cor(water.sand %>% select(-station))
  
# find and eliminate the highly correlated variables. NB names = FALSE, to return column index
highly.cor.water.sand <- findCorrelation(water.sand.cors, cutoff = 0.85)

water.sand.red <- water.sand %>% 
  select(-station) %>% # otherwise column indices don't match 
  select(-highly.cor.water.sand)


water.sand.pca <- prcomp(water.sand.red, center = TRUE, scale. = TRUE) 

# check the results
summary(water.sand.pca)
biplot(water.sand.pca)
```

Unfortunately, this eliminates LUSI, which as we saw is highly correlated with all nutrients, etc. - and I'd like to keep it, to check against macrozoobenthic community structure.  
However, for the sake of not throwing away hard work, I will go through the motions of visualizing and exploring the PCA results. Procedure uses packages FactoMineR and factoextra.  
```{r pca_water_sand}
# scale and center the data (different units), and add back the stations 
water.sand.red.scaled <- scale(water.sand.red, center = TRUE, scale = TRUE)
water.sand.red.scaled <- bind_cols(water.sand %>% select(station), 
                                   as.tibble(water.sand.red.scaled))

## perform PCA with FactoMineR - it's equivalent to the base version, anyway, but the visualization expects a particular structure of the results, so easier to do it this way. 
water.sand.pca.fin <- PCA(water.sand.red.scaled,
                          scale.unit = FALSE, 
                          quali.sup = 1, 
                          graph = FALSE)

## display the summary and biplot
summary(water.sand.pca.fin)

(plot.water.sand.pca <- fviz_pca_biplot(water.sand.pca.fin, axes = c(1, 2), 
                                        label = c("var", "ind"), 
                                        col.var = "cos2", gradient.cols = c("skyblue", "navyblue", "red"), 
                                        repel = TRUE)
)

ggsave(here(figures.dir, "pca_water_sand.png"), plot.water.sand.pca, dpi = 300)
```
The first 2 PCs explain ~73% of the total variance - not too bad.. Add the third, and the proportion of the explained variance becomes nearly 90%.  
Stations 2 and 6, then 1 and 4 contribute the most to the first PC (Dim.1), nad are best represented on it (cos2). Stations 1, 4, 2 and 3 contribute the most to PC2, and are again best represented on it (see also the supplementary categories table).   
On a plot of PC1-2, the separation is between stations 1 2 in one end (to the left), and stations 4 and 6 in the other (right); stations 3 and 5 are close  together near the middle (not too well represented).    
In terms of variables, PC1 can be considered a representation of the eutrophication gradient - highly correlated with Ntotal and chl-a on one side ("pulling" to the left), and with bottom O2 (and total O2) on the other ("pulling" to the right). PC2 represents mainly the temperature ("pulls" down), and to a lesser degree - NO3.  

Since I did these, I found out about a new package doing **automatic** exploration & report on the PCA - FactoInvestigate. Let's try it out, see what we get..  
```{r report_pca_water_sand}
Investigate(water.sand.pca.fin, file = here(save.dir, "pca_report_water_sand.Rmd"), document = "pdf_document", parallel = TRUE)
```

The automatic report **fails** at the attempt to describe the dimensions - that's because there is nothing to describe; the orignal data only has 1 value per station - not really appropriate for PCA, which attempts to describe variability after all (what variability with only 1 value?).  
Before that, it manages to say that the analysis should not be attempted at all - see generated report. Quoting: "An estimation of the right number of axes to interpret suggests to not interpret the analysis at all.  Indeed, the amount of inertia of the first axis is not higher than that obtained by the 0.95-quantile of random distributions (46.6% against 61.68%). This observation suggests that no axis is carrying a real information."

**Also, I don't like how LUSI got excluded - I think in the end, I might just show the correlation table to demonstrate that LUSI reflects well the eutrophication gradient, then just pass it on to the community structure analyses. Will dramatically reduce the number of variables + the uncertainty associated with only a few discrete samples of highly variable parameters such as nutrients and oxygen.**  

In any case, let's save the PCA result - just in case, to avoid repeating a million times later.   
```{r save_pca_water_sand}
write_rds(water.sand.pca.fin, path = here(save.dir, "pca_water_sand.RDS"))
```

***  
##### Sidebar: PCA result exploration - demonstrated on water parameters on sand stations, 2013-14   
PCA done like this is meaningless.  
However, let's explore the results a bit - just to demonstrate the basic procedure with PCA quality checks & interpretation.   
1) Check the variances of the principal components. Amount of variation retained by each PC = eigenvalue. First PC = direction with maximum amount of variation in the dataset.  
```{r explore_pca_water_sand_1}
water.sand.pca.fin$eig
```
2) Visualize the importance of the PCs (-> scree plot).   
```{r explore_pca_water_sand_2}
fviz_screeplot(water.sand.pca.fin)
```
3) Plot correlations/loadings of the variables with the PCs = variable loadings. Variables can be plotted as points in the component space using their loadings as coordinates.  
```{r explore_pca_water_sand_3}
## look at variable coordinates on each PC
water.sand.pca.fin$var$coord

## visualize the variables on the factor map. Correlation circle can help visualize the most correlated variables (variables that group together). 
fviz_pca_var(water.sand.pca.fin, col.circle = "grey")
```

4) Explore the quality of the representation for variables on the factor map (cos2 = squared loadings for variables = cor x cor = coord x coord). The closer a variable to the circle of correlations, the better its representation on the factor map, and the more important it is to interpret these components. If a variable is perfectly represented by only 2 components, the sum of the cos2 = 1, and the variables will be positioned on the circle of correlations. For some variables - more than 2 components required to perfectly represent the data; then - variables positioned inside circle of correlations. Variables close to the center of the plot - less important for the first components.  
```{r explore_pca_water_sand_4}
## check the variables with highest correlation to the first few PCs
as_tibble(water.sand.pca.fin$var$cos2, rownames = "var") %>%
  arrange(desc(Dim.1))

## plot the variables factor map, and color the vectors according to the amount of correlation to the PCs. Can select the minimum value of cos2 and the PC axes to plot.
# PC1-PC2
fviz_pca_var(water.sand.pca.fin, axes = c(1, 2), select.var = list(cos2 = 0.5), 
             col.var = "cos2", gradient.cols = c("skyblue", "navyblue", "red"))

# PC1-PC3
fviz_pca_var(water.sand.pca.fin, axes = c(1, 3), select.var = list(cos2 = 0.5), 
             col.var = "cos2", gradient.cols = c("skyblue", "navyblue", "red"))

```

5) Check the contributions of the variables to the PCs. Variables that are correlated with PC1 and PC2 - the most important in explaining the variability in the dataset.  
Variables not correlated with any PC or correlated with the last dimensions - low contribution; could be removed to simplify overall analysis.  
% contribution of a variable in accounting for the variability in a given PC = (variable.cos2 x 100) / (total cos2 of component)  
```{r explore_pca_water_sand_5}
as_tibble(water.sand.pca.fin$var$contrib, rownames = "var") %>%
  arrange(desc(Dim.1))
```

6) Visualize the most important variables associated with a given PC. The red line on the graph represents the expected average contribution (if all variable contributions were uniform). For a given component, any variable with contribution larger than that cutoff could be considered important.  
```{r explore_pca_water_sand_6}
plot_pca_var_contrib <- function(pca.res, choice = c("var", "ind"), axes = c(start : end)) {
  ## helper for plotting variable/individuals contributions (as bars) to the specified PC axes. 
  ## Dependencies: factoextra
  
  # plot contributions for each axis separately
  for(i in axes){
    print(fviz_contrib(pca.res, choice = choice, axes = i))
  }
  
  # plot the overall contributions to the specified axes
  print(fviz_contrib(pca.res, choice = choice, axes = axes))
}



# variable contributions on PC1, PC2 and PC3 (+ all 3 axes together)
plot_pca_var_contrib(water.sand.pca.fin, 
                     choice = "var", 
                     axes = c(1:3))


# if there are many variables in the dataset, we can show only the top n contributing variables:
fviz_contrib(water.sand.pca.fin, choice = "var", axes = 1, top = 5)

```

7) Color variables on the variable factor map according to their contributions - highlights the most important variables in explaining the variations retained  by the PCs.
```{r explore_pca_water_sand_7}
fviz_pca_var(water.sand.pca.fin, col.var = "contrib") 

## variable contributions to PC1-2
fviz_pca_var(water.sand.pca.fin, axes = c(1, 2), col.var = "contrib") 
##..and to PC1-3
fviz_pca_var(water.sand.pca.fin, axes = c(1, 3), col.var = "contrib")

```

8) Dimension description - identify the most correlated variables with a given PC -> but only works with more categories (e.g. replicates at the stations, years,..). I'm including it as a reminder that it exists as an option.    
```{r explore_pca_water_sand_8}
# dimdesc(water.sand.pca.fin, axes = c(1:5))
```

9) Explore individuals (= stations/species/..) in the same way as the variables just now.  
```{r explore_pca_water_sand_9}
## coordinates of individuals on the PCs
water.sand.pca.fin$ind$coord

## plot & label by station (can also colour by group - year,..)
fviz_pca_ind(water.sand.pca.fin, label = c("quali", "ind"))

## quality of representation for individuals on the PCs (cos2)
as_tibble(water.sand.pca.fin$ind$cos2, rownames = "ind") %>% 
  arrange(desc(Dim.1))

## correlation of individuals with PC1-2
fviz_pca_ind(water.sand.pca.fin, axes = c(1, 2), col.ind = "cos2", gradient.cols = c("skyblue", "navyblue", "red")) 

## ...and with PC1-3
fviz_pca_ind(water.sand.pca.fin, axes = c(1, 3), col.ind = "cos2", gradient.cols = c("skyblue", "navyblue", "red")) 

## contribution of individuals to the PCs
as_tibble(water.sand.pca.fin$ind$contrib, rownames = "ind") %>% 
  arrange(desc(Dim.1))

## visualize the most contributing individuals (stations) associated with a given PC
# PC1-3 + all 3 together (custom function)
plot_pca_var_contrib(water.sand.pca.fin, 
                     choice = "ind", 
                     axes = c(1:3))

## top 3 individuals (stations) contributing to PC1 (for ex.)
fviz_contrib(water.sand.pca.fin, choice = "ind", axes = 1, top = 3)

## individuals (stations) map colored according to their contribution
fviz_pca_ind(water.sand.pca.fin, col.ind = "contrib")

```

***  

Let's try again with the **sediment parameters** - there are more values per station here, so should turn out better.  
```{r pca_sediments_sand}
# scale and center the data (different units), and add back the stations 
sediments.sand.scaled <- scale(sediments.sand %>% select(-c(station:year)), center = TRUE, scale = TRUE)
sediments.sand.scaled <- bind_cols(sediments.sand %>% select(station), 
                                   as.tibble(sediments.sand.scaled))

sediments.sand.pca <- PCA(sediments.sand.scaled, scale.unit = FALSE, quali.sup = 1)
Investigate(sediments.sand.pca, file = "pca_sediments_sand_report.Rmd", document = "html_document", remove.temp = TRUE)
```

*NB The knitting of the report fails if I try to put it in a subfolder of the working directory, so I'll just move it by hand afterwards - it will live in the output directory.*   

To summarize the report: the first two PCs capture a significant proportion of the variability of the dataset. The first PC is major - the estimation of the right number of axis to interpret suggests to restrict the analysis to the description of the first 1 axis.   
The dimension 1 opposes individuals such as 2, 1, 14, 13, 15 and 3 (Kraimorie and Agalina - to the right of the graph, characterized by a strongly positive coordinate on the axis) to individuals such as 7, 9 and 8 (Akin - to the left of the graph, characterized by a strongly negative coordinate on the axis).  
The group of individuals 2, 14, 13 and 15 (mostly Agalina) has:  
• high values for the variables gravel, moisture_content, mean_grain_size and sorting (strongest to weakest).  
• low values for the variable sand.  
The group of individuals 1 and 3 (Kraimorie) has:  
• high values for the variables silt_clay, TOM and sorting (strongest to weakest).  
The group of individuals 7, 9 and 8 (Akin) has:  
• high values for the variable sand.  
• low values for the variables mean_grain_size, sorting, gravel, TOM and moisture_content (weakest to strongest).  
**The variables mean_grain_size, sorting, sand and Sozopol(?) are highly correlated with this dimension (respective correlation of 0.93, 0.96, 0.93, 0.91). These variables could therefore summarize themselves the dimension 1.**   
All in all, the PCA describes well the differences in sediment composition between stations. The stations form **4 main clusters**:    
- cluster 1 is made of individuals such as 7, 8 and 9 (Akin), with high values for the variable sand, and low values for the variables TOM, moisture_content, sorting, mean_grain_size and gravel (weakest to strongest).  
- cluster 2 is made of individuals such as 16 and 18 (Paraskeva), with high values for the variable moisture_content.  
- cluster 3 is made of individuals such as 2, 13, 14 and 15 (Agalina), with high values for the variables gravel, mean_grain_size and sorting (strongest to weakest), and low values for the variable sand.   
- cluster 4 is made of individuals such as 1 and 3 (Kraimorie), with high values for the variables silt_clay, TOM and sorting (strongest to weakest).  
Kraimorie and Agalina are similar in their sediment chracteristics (larger mean grain size, gravel & organic matter content), which could possibly explain similarities in their macrozoobenthic community structure.  
Same for Akin, (Sozopol) and Paraskeva - smaller grain size, predominantly sand.  
Chukalya is in the middle, but closer to the sandy stations.  

Final try, with the **heavy metals** - although same problem as water column parameters - no variability, just 1 measurement/station.  


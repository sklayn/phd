---
title: "Environmental parameters - analysis & variable selection"
date: "2018-04-11"
output: 
  html_notebook:
    theme: paper
---
  
Setup!  
```{r setup, include = FALSE}
library(knitr)

knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(2, 2, .1, 2))  # smaller margin on top
})

## set the working directory to one up (all notebooks - kept in their own subdirectory within the project directory).
opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

## set knitr options for knitting code into the report.
opts_chunk$set(cache = TRUE, # save results so that code blocks aren't re-run unless code changes
               autodep = TRUE, # ..or unless a relevant earlier code block changed
               cache.comments = FALSE, # don't re-run if the only thing that changed was the comments
               highlight = TRUE, 
               small.mar = TRUE)
```

Define the working subdirectories.  
```{r workspace_setup}
## print the working directory, just to be on the safe side
paste("You are here: ", getwd())

data.dir <- "data"    # input data files
functions.dir <- "R"  # functions & scripts
save.dir <- "output"  # clean data, output from models & more complex calculations
figures.dir <- "figs" # plots & figures 
```

Import libraries.  
```{r import_packages, results = FALSE}
library(here) # painless relative paths to subdurectories, etc.
library(tidyverse) # data manipulation, cleaning, aggregation
library(viridis) # smart & pretty colour schemes
library(caret) # variable selection, pruning & other wrapper functions for modeling

library(FactoMineR) # PCA
library(factoextra) # visualization & exploration of PCA results

# if not installed:
# devtools::install_github("kassambara/factoextra")
# install.packages("FactoMineR", "factoextra")

library(glmnet) # elastic net variable selection & model fitting 
```

Organize some commonly-used ggplot2 modifications into a more convenient (and less repetitive) format.  
```{r custom_ggplot_settings_helpers}
## ggplot settings & things that I keep reusing
# ggplot_theme <- list(
#   theme_bw(),
#   theme(element_text(family = "Times"))
# )

## always use black-and-white theme
theme_set(theme_bw())

## helper to adjust ggplot text size & avoid repetitions 
text_size <- function(text.x = NULL,
                      text.y = NULL,
                      title.x = NULL,
                      title.y = NULL,
                      legend.text = NULL,
                      legend.title = NULL, 
                      strip.x = NULL, 
                      strip.y = NULL) {
  theme(axis.text.x = element_text(size = text.x),
        axis.text.y = element_text(size = text.y),
        axis.title.x = element_text(size = title.x),
        axis.title.y = element_text(size = title.y),
        legend.text = element_text(size = legend.text), 
        legend.title = element_text(size = legend.title), 
        strip.text.x = element_text(size = strip.x), 
        strip.text.y = element_text(size = strip.y)
        )
}

```

***  

This notebook details the analyses & variable selection of the environmental parameters. I'm giving them their own notebook for clarity and simplicity.  
This is a direct continuation of the cleanup & summarization notebook on environmental parameters; I'm going to import some of the summary tibbles produced there directly from the save folder.    
Again, the analyses will proceed in 3 separate datasets: 2012, sand (2013-2014), and seagrass (2013-2014).   
Two lines of analysis will be applied:  
1) PCA - to see which variables best account for the differences between stations. The "winners" will go on to the multivariate analyses attempting to relate community structure to environment.  
PCA will be applied on 3 sets of explanatory variables - water column (+ LUSI), sediments (+ seagrass, where relevant), and heavy metals; y = station (and habitat, in the case of sand). Prior to the PCA, some (feeble) variable selection will be performed - mostly to get rid of highly correlated variables.  
2) Elastic net - another method of variable selection.  
Again, there will be 3 sets of explanatory variables - as above.  
y = categorical (station, habitats) - logistic regression with multinomial models & grouped lasso penalty.  
y = numeric (species abundances) - multi-response Gaussian linear regression with many correlated responses (+ maybe should be applied over a sparse matrix).  

##### Sand stations (Burgas Bay, 2013-2014)  
Import environmental data.   
```{r import_water_data_sand}
## contains the long-term water column parameters, summarized by station. 
water <- read_csv(here(save.dir, "water_column_summary_LT.csv"))

## filter (manually) to get only the sand 2013-2014 stations
(water.sand <- water %>% 
    filter(station %in% c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva"))
)
```

Import the sediment data (it also contains the heavy metals).   
```{r import_sediment_data_sand}
sediments <- read_csv(here(save.dir, "sediments_imputed_sand.csv"))

## split into sediment parameters sesnu stricto, and heavy metals
(sediments.sand <- sediments %>% 
    select(station:year, TOM:silt_clay)
)  

(heavy.metals.sand <- sediments %>% 
    select(station:year, Cu:Ni) 
)
```

Import LUSI and add it to the water column data, although strictly speaking, it isn't really..  
```{r import_lusi_sand}
(lusi <- read_csv(here(save.dir, "lusi_st.csv"))
)

## we'll match them by station - and we only want the sand stations - the rows of x (the water column data) where there are matching values in y (LUSI) -> e.g. inner join 
(water.sand <- inner_join(water.sand, 
                          lusi %>% select(-watershed), 
                          by = "station")
)
```
The nutrients all decrease towards the outer bay, more or less so, and so do the chl-a and suspended matter; the transparency (Secchi depth) increases - this is the long-term (anthropgenic) eutrophication gradient in Burgas Bay, consistent with previous studies (..) & models.   

Now let's check the correlations between water column parameters. More or less important: LUSI is (significantly) positively correlated with most long-term nutrient concentrations, chl-a and suspended matter, and negatively correlated with Secchi depth, which is good - shows that it's a good indicator of the anthropogenic pressure gradient of Burgas Bay. Could maybe be used as a proxy for all of these in the analyses? As a side note, the fact that it doesn't require the analyses of samples upon water samples is also not too shabby.     
```{r water_sand_correlations}
Hmisc::rcorr(as.matrix(water.sand %>% select(-station)), 
             type = "pearson")
```
  
Now we'll proceed with the variable selection for the PCA. For whatever it's worth, I don't think PCA with so few observations can be valid, but hey, all the kids are doing it.    
We'll just eliminate the most inter-correlated variables using package caret.  
```{r filter_correlated_sand}
# calculate the correlation matrix (on the numeric variables only)
water.sand.cors <- cor(water.sand %>% select(-station))
  
# find and eliminate the highly correlated variables. NB names = FALSE, to return column index
highly.cor.water.sand <- findCorrelation(water.sand.cors, cutoff = 0.85)

water.sand.red <- water.sand %>% 
  select(-station) %>% # otherwise column indices don't match 
  select(-highly.cor.water.sand)


water.sand.pca <- prcomp(water.sand.red, center = TRUE, scale. = TRUE) 

# check the results
summary(water.sand.pca)
biplot(water.sand.pca)
```

Unfortunately, this eliminates LUSI, which as we saw is highly correlated with all nutrients, etc. - and I'd like to keep it, to check against macrozoobenthic community structure.  
However, for the sake of not throwing away hard work, I will go through the motions of visualizing and exploring the PCA results. Procedure uses packages FactoMineR and factoextra.  
```{r pca_water_sand}
# scale and center the data (different units), and add back the stations 
water.sand.red.scaled <- scale(water.sand.red, center = TRUE, scale = TRUE)
water.sand.red.scaled <- bind_cols(water.sand %>% select(station), 
                                   as.tibble(water.sand.red.scaled))

## perform PCA with FactoMineR - it's equivalent to the base version, anyway, but the visualization expects a particular structure of the results, so easier to do it this way. 
water.sand.pca.fin <- PCA(water.sand.red.scaled,
                          scale.unit = FALSE, 
                          quali.sup = 1, 
                          graph = FALSE)

## display the summary and biplot
summary(water.sand.pca.fin)

(plot.water.sand.pca <- fviz_pca_biplot(water.sand.pca.fin, axes = c(1, 2), 
                                        label = c("var", "ind"), 
                                        col.var = "cos2", gradient.cols = c("skyblue", "navyblue", "red"), 
                                        repel = TRUE)
)

ggsave(here(figures.dir, "pca_water_sand.png"), plot.water.sand.pca, dpi = 300)
```
The first 2 PCs explain ~73% of the total variance - not too bad.. Add the third, and the proportion of the explained variance becomes nearly 90%.  
Stations 2 and 6, then 1 and 4 contribute the most to the first PC (Dim.1), nad are best represented on it (cos2). Stations 1, 4, 2 and 3 contribute the most to PC2, and are again best represented on it (see also the supplementary categories table).   
On a plot of PC1-2, the separation is between stations 1 2 in one end (to the left), and stations 4 and 6 in the other (right); stations 3 and 5 are close  together near the middle (not too well represented).    
In terms of variables, PC1 can be considered a representation of the eutrophication gradient - highly correlated with Ntotal and chl-a on one side ("pulling" to the left), and with bottom O2 (and total O2) on the other ("pulling" to the right). PC2 represents mainly the temperature ("pulls" down), and to a lesser degree - NO3.  

Good enough, if it's even valid with so few observations, summarized data and all...   
**Also, I don't like how LUSI got excluded - I think in the end, I might just show the correlation table to demonstrate that LUSI reflects well the eutrophication gradient, then just pass it on to the community structure analyses. Will dramatically reduce the number of variables + the uncertainty associated with only a few discrete samples of highly variable parameters such as nutrients and oxygen.**  

In any case, let's save the PCA result - just in case, to avoid repeating a million times later.  
```{r save_pca_water_sand}
write_rds(water.sand.pca.fin, path = here(save.dir, "pca_water_sand.RDS"))
```

Let's explore the results a bit - just to demonstrate the basic procedure with PCA quality checks & interpretation.   
1) Check the variances of the principal components. Amount of variation retained by each PC = eigenvalue. First PC = direction with maximum amount of variation in the dataset.  
```{r explore_pca_water_sand_1}
water.sand.pca.fin$eig
```
2) Visualize the importance of the PCs (-> scree plot).   
```{r explore_pca_water_sand_2}
fviz_screeplot(water.sand.pca.fin)
```
3) Plot correlations/loadings of the variables with the PCs = variable loadings. Variables can be plotted as points in the component space using their loadings as coordinates.  
```{r explore_pca_water_sand_3}
## look at variable coordinates on each PC
water.sand.pca.fin$var$coord

## visualize the variables on the factor map. Correlation circle can help visualize the most correlated variables (variables that group together). 
fviz_pca_var(water.sand.pca.fin, col.circle = "grey")
```

4) Explore the quality of the representation for variables on the factor map (cos2 = squared loadings for variables = cor x cor = coord x coord). The closer a variable to the circle of correlations, the better its representation on the factor map, and the more important it is to interpret these components. If a variable is perfectly represented by only 2 components, the sum of the cos2 = 1, and the variables will be positioned on the circle of correlations. For some variables - more than 2 components required to perfectly represent the data; then - variables positioned inside circle of correlations. Variables close to the center of the plot - less important for the first components.  
```{r explore_pca_water_sand_4}
## check the variables with highest correlation to the first few PCs
as_tibble(water.sand.pca.fin$var$cos2, rownames = "var") %>%
  arrange(desc(Dim.1))

## plot the variables factor map, and color the vectors according to the amount of correlation to the PCs. Can select the minimum value of cos2 and the PC axes to plot.
# PC1-PC2
fviz_pca_var(water.sand.pca.fin, axes = c(1, 2), select.var = list(cos2 = 0.5), 
             col.var = "cos2", gradient.cols = c("skyblue", "navyblue", "red"))

# PC1-PC3
fviz_pca_var(water.sand.pca.fin, axes = c(1, 3), select.var = list(cos2 = 0.5), 
             col.var = "cos2", gradient.cols = c("skyblue", "navyblue", "red"))

```

5) Check the contributions of the variables to the PCs. Variables that are correlated with PC1 and PC2 - the most important in explaining the variability in the dataset.  
Variables not correlated with any PC or correlated with the last dimensions - low contribution; could be removed to simplify overall analysis.  
% contribution of a variable in accounting for the variability in a given PC = (variable.cos2 x 100) / (total cos2 of component)  
```{r explore_pca_water_sand_5}
as_tibble(water.sand.pca.fin$var$contrib, rownames = "var") %>%
  arrange(desc(Dim.1))
```

6) Visualize the most important variables associated with a given PC. The red line on the graph represents the expected average contribution (if all variable contributions were uniform). For a given component, any variable with contribution larger than that cutoff could be considered important.  
```{r explore_pca_water_sand_6}
plot_pca_var_contrib <- function(pca.res, choice = c("var", "ind"), axes = c(start : end)) {
  ## helper for plotting variable/individuals contributions (as bars) to the specified PC axes. 
  ## Dependencies: factoextra
  
  # plot contributions for each axis separately
  for(i in axes){
    print(fviz_contrib(pca.res, choice = choice, axes = i))
  }
  
  # plot the overall contributions to the specified axes
  print(fviz_contrib(pca.res, choice = choice, axes = axes))
}



# variable contributions on PC1, PC2 and PC3 (+ all 3 axes together)
plot_pca_var_contrib(water.sand.pca.fin, 
                     choice = "var", 
                     axes = c(1:3))


# if there are many variables in the dataset, we can show only the top n contributing variables:
fviz_contrib(water.sand.pca.fin, choice = "var", axes = 1, top = 5)

```

7) Color variables on the variable factor map according to their contributions - highlights the most important variables in explaining the variations retained  by the PCs.
```{r explore_pca_water_sand_7}
fviz_pca_var(water.sand.pca.fin, col.var = "contrib") 

## variable contributions to PC1-2
fviz_pca_var(water.sand.pca.fin, axes = c(1, 2), col.var = "contrib") 
##..and to PC1-3
fviz_pca_var(water.sand.pca.fin, axes = c(1, 3), col.var = "contrib")

```

8) Dimension description - identify the most correlated variables with a given PC -> but only works with more categories (e.g. replicates at the stations, years,..). I'm including it as a reminder that it exists as an option.    
```{r explore_pca_water_sand_8}
# dimdesc(water.sand.pca.fin, axes = c(1:5))
```

9) Explore individuals (= stations/species/..) in the same way as the variables just now.  
```{r explore_pca_water_sand_9}
## coordinates of individuals on the PCs
water.sand.pca.fin$ind$coord

## plot & label by station (can also colour by group - year,..)
fviz_pca_ind(water.sand.pca.fin, label = c("quali", "ind"))

## quality of representation for individuals on the PCs (cos2)
as_tibble(water.sand.pca.fin$ind$cos2, rownames = "ind") %>% 
  arrange(desc(Dim.1))

## correlation of individuals with PC1-2
fviz_pca_ind(water.sand.pca.fin, axes = c(1, 2), col.ind = "cos2", gradient.cols = c("skyblue", "navyblue", "red")) 

## ...and with PC1-3
fviz_pca_ind(water.sand.pca.fin, axes = c(1, 3), col.ind = "cos2", gradient.cols = c("skyblue", "navyblue", "red")) 

## contribution of individuals to the PCs
as_tibble(water.sand.pca.fin$ind$contrib, rownames = "ind") %>% 
  arrange(desc(Dim.1))

## visualize the most contributing individuals (stations) associated with a given PC
# PC1-3 + all 3 together (custom function)
plot_pca_var_contrib(water.sand.pca.fin, 
                     choice = "ind", 
                     axes = c(1:3))

## top 3 individuals (stations) contributing to PC1 (for ex.)
fviz_contrib(water.sand.pca.fin, choice = "ind", axes = 1, top = 3)

## individuals (stations) map colored according to their contribution
fviz_pca_ind(water.sand.pca.fin, col.ind = "contrib")

```


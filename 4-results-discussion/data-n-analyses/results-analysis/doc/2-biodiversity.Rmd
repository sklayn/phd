---
title: "Biodiversity of macrozoobenthic communities - 2"
date: "2017-11-30"
output: 
  html_notebook:
    theme: paper
---

## Biodiversity, taxonomic distinctness & graphical community analyses  
This is a continuation of the community analyses started in part 1. Includes the selection of more sophisticated descriptive community analyses of biodiversity, again applied on the 3 separate datasets.  

*** 
  Some setup, to make this notebook stand-alone.
```{r setup, include = FALSE}
library(knitr)
knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(2, 2, .1, 2))  # smaller margin on top
})

## set the working directory to one up (all notebooks - kept in their own subdirectory within the project directory).
opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

## set knitr options for knitting code into the report.
opts_chunk$set(cache = TRUE, # save results so that code blocks aren't re-run unless code changes
               autodep = TRUE, # ..or unless a relevant earlier code block changed
               cache.comments = FALSE, # don't re-run if the only thing that changed was the comments
               highlight = TRUE, 
               small.mar = TRUE)
```
  Define the working subdirectories.
```{r workspace_setup}
## print the working directory, just to be on the safe side
paste("You are here: ", getwd())

data.dir <- "data"    # input data files
functions.dir <- "R"  # functions & scripts
save.dir <- "output"  # clean data, output from models & more complex calculations
figures.dir <- "figs" # plots & figures 
```
  Import functions.
```{r import_custom_functions}
source(file.path(functions.dir, "alpha_diversity.R"))
```
  
  Import the necessary libraries.  
```{r import_packages, message = FALSE}
library(vegan)
library(tidyverse)
library(viridis)
```
  Organize some commonly-used ggplot2 modifications into a more convenient (and less repetitive) format.
```{r custom_ggplot_settings_helpers}
## ggplot settings & things that I keep reusing
# ggplot_theme <- list(
#   theme_bw(),
#   theme(element_text(family = "Times"))
# )
## always use black-and-white theme
theme_set(theme_bw())

## helper to adjust ggplot text size & avoid repetitions 
text_size <- function(text.x = NULL,
                      text.y = NULL,
                      title.x = NULL,
                      title.y = NULL,
                      legend.text = NULL,
                      legend.title = NULL, 
                      strip.x = NULL, 
                      strip.y = NULL) {
  theme(axis.text.x = element_text(size = text.x),
        axis.text.y = element_text(size = text.y),
        axis.title.x = element_text(size = title.x),
        axis.title.y = element_text(size = title.y),
        legend.text = element_text(size = legend.text), 
        legend.title = element_text(size = legend.title), 
        strip.text.x = element_text(size = strip.x), 
        strip.text.y = element_text(size = strip.y)
        )
  }
```
***
#### Macrozoobenthic communities in the sandy sediments of Burgas Bay (2013-2014)
Import the zoobenthic abundance & biomass data - as an exception, from the cleaned & saved datasets, to avoid (most of) the cleaning steps. 
```{r zoo_data_sand_import, message = FALSE, results = FALSE}
## dimensions should be 54 x 205 (5 metadata + 200 species columns); all species columns should be numeric.
zoo.abnd.sand <- read_csv(file.path(save.dir, "abnd_sand_orig_clean.csv"))

## same for biomass; same expected structure as the abundance
zoo.biomass.sand <- read_csv(file.path(save.dir, "biomass_sand_orig_clean.csv"))
```
  Convert columns to the proper type, arrange the datasets by station, etc.
```{r clean_zoo_data_sand, results = FALSE}
zoo.abnd.sand <- zoo.abnd.sand %>% 
  mutate(station = factor(station, levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva"))) %>%
  arrange(station, year, month)

zoo.biomass.sand <- zoo.biomass.sand %>% 
  mutate(station = factor(station, levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva"))) %>%
  arrange(station, year, month)
```
  Remove all species not present in the datasets (= all-0 columns). 
```{r clean_zoo_data_sand_2, results = FALSE}
## result should have dimensions 54 x 152 (147 species + 5 metadata columns) 
zoo.abnd.sand <- zoo.abnd.sand %>% 
  gather(key = species, value = sp_count, -c(station:replicate)) %>% 
  group_by(species) %>% 
  filter(sp_count > 0) %>%
  spread(species, sp_count, fill = 0) %>%
  arrange(station, year, month)

zoo.biomass.sand <- zoo.biomass.sand %>% 
  gather(key = species, value = sp_biomass, -c(station:replicate)) %>% 
  group_by(species) %>% 
  filter(sp_biomass > 0) %>%
  spread(species, sp_biomass, fill = 0) %>%
  arrange(station, year, month)
```
  
##### Alpha diversity indices  
All of the following can be calculated using package vegan. 
  + species richness S  
  + Shannon-Wiener biodiversity index H' (log2) - quantifies the probability that any two species drawn from the community are different - measure of entropy, NOT diversity! Therefore doesn't behave linearly. Actually measures the level of disorder in the system (more disorder = more diversity).    
  + Pielou evenness index J' - - level of dominance in the community. Close to 1 - the abundance is more evenly distrbuted among the species; close to 0 - one or several species largely dominate in abundance over the others.    
  + effective Shannon diversity (= corresponding Hill number) - to allow a meaningful comparison of diversity, not of entropy. Effective numbers impose a linear transformation on Shannon diversity - represent the number of equally abundant species necessary to produce the observed value of diversity. Range from 1 to S, where a value of S would indicate all species are present and in equal abundances.  
```{r alpha_diversity_sand}
## uses custom function for convenience - has to be imported first! 
alpha.div.sand <- zoo.abnd.sand %>%
  select(-c(station:replicate)) %>%
  alpha_diversity()

## add the metadata columns (row order is not changed, so possible) 
(alpha.div.sand <- bind_cols(zoo.abnd.sand %>% select(station:replicate), alpha.div.sand)
)
```
  Summarize these diversity indices by station & year.
```{r summarize_alpha_diversity_sand}
## might be a good place to eventually learn how to use the functions from package sjPlot for printing pretty (and easy!) tables...   
alpha.div.sand %>% 
  group_by(station, year) %>%
  summarise(h_mean = mean(shannon_h), h_sd = sd(shannon_h), 
            j_mean = mean(evenness_j), j_sd = sd(evenness_j),
            h_eff_mean = mean(h_effective), h_eff_sd = sd(h_effective)
            )
```
  
2. Species accumulation curves - see how species are added when the number of samples (sites) increases. Usually used to see if the sampling effort is adequate & captures most of the diversity in the study area.  
```{r sp_accumulation_curves_sand}
sac.sand <- specaccum(select(zoo.abnd.sand, -c(station:replicate)))

plot(sac.sand, 
     xlab = "Samples", ylab = "Cumulative species richness", 
     ci.type = "polygon", ci.col = "light blue")
```
  About 10 samples seem to be enough to capture most of the biodiversity in the study area (in terms of species richness) - this is where the curve starts to smooth out (slope < 1). In my dataset, there are 9 samples/station - could be considered enough.  
  NB IF this method is applied correctly, since the samples are not independent but in fact represent replicates at each station.  
  
##### Species pool  
The species pool is the total extrapolated number of species in the study area (various estimates used here). Used to estimate the number of **unobserved species**. The functions assume that the number of unobserved species is related to he number of rare species (= seen only once or twice).     
```{r sp_pool_sand}
## this function is based on incidences in sample sites - presence/absence data; gives a single estimate for a collection of sample sites
specpool(select(zoo.abnd.sand, -c(station:replicate)), 
         pool = zoo.abnd.sand$station, 
         smallsample = TRUE)

## this function is quantitative - based on abundances on single sample site
estimateR(select(zoo.abnd.sand, -c(station:replicate)))
```
  Now let's do it for the whole dataset. 
```{r sp_pool_total_sand}
specpool(select(zoo.abnd.sand, -c(station:replicate)), 
         smallsample = TRUE)
```
  Looks good: based on the most severe estimate (second-order jacknife), the dataset captures about 77 % of the species pool, and based on the most forgiving one (bootstrap) - about 91 %.  
  
##### Taxonomic distance & diversity  
  Simple diversity measures do not distinguish between species. However, in the real world, species relationships (phylogenetic, taxonomic, functional..) matter, and could carry important ecologcial information.    
  For these analyses, a master species list for the whole study area is needed. For the Black Sea, it was compiled using the Catalogue of Black Sea Fauna & its 2 updates, as well as other, more recent inventories (full references & details in Materials & methods).  
```{r import_master_taxonomic_list}
## NB imported with row names on purpose, otherwise later some vegan functions fail! 
master.tax.list <- read.csv(file = file.path(data.dir, "td_zoo_taxonomy.csv"), header = TRUE, row.names = 1)
```
  Now we'll calculate the **taxonomic distance** for the dataset.
```{r tax_distance_sand}
## calculate the taxonomic distance for the master species list, using variable step - scaling according to reduction in number of classes when going up in the tax. tree (if almost all genera have only 1 species, it makes no big difference if 2 individuals belong to a different species or a different genus). 
tax.dist.sand <- taxa2dist(master.tax.list, varstep = TRUE)

## calculate the taxonomic distinctness indices for the abundance dataset, and print it to examine (its built-in print method is actually better than mine, after later conversions to tibble, etc.)
(tax.distinctness.sand <- taxondive(select(zoo.abnd.sand, -c(station:replicate)), tax.dist.sand)
)

## get the summary - includes a significance test on Delta+
summary(tax.distinctness.sand)

```
  Construct the 95% confidence funnels for the taxonomic distance using the master species list. Actually, these were probably meant to be 95% tolerance intervals (limits containing at least 95% of all observations), so that's what I'm going to calculate.  
  Thankfully, I can do this once for all three datasets - the simulation takes a lot of time and computational power.  
```{r simulate_tax_distance_indices}
sim.list <- seq(from = 10, to = 150, by = 5) 

simulate_Dplus_L <- function(master.list, tax.dist.mat, species) {
  ## helper calculating taxonomic distinctness indices Dplus and Lambda for a simulated community sampled at random from the master species list for the study area   
  
  ## simulate a possible community of the specified size from the master species list for the study area
  sim.community <- dplyr::sample_n(master.list, size = species, replace = FALSE)
  
  ## convert to a matrix, to use in vegan function taxondive 
  sim.community.mat <- matrix(1, nrow = 1, ncol = nrow(sim.community))
  colnames(sim.community.mat) <- row.names(sim.community)
  
  ## calculate & extract Dplus for the simulated community, suppressing the messages related to dimension mismatch with the master list 
  dplus.l <- suppressMessages(vegan::taxondive(sim.community.mat, tax.dist.mat)[c("Dplus", "Lambda")])
  
  return(dplus.l)
}

## generate the Dplus values for each simulated dataset - using the parallel version of sapply + replicate; ~11 min for 29000 values
library(parallel)
core.clust <- makeCluster(detectCores() - 2, type = "FORK") # make core cluster (leaving some threads for the other processes the computer is running), making sure to fork the environment, otherwise the functions won't be able to find objects in the global environment

dplus.l.sim <- parSapply(core.clust, sim.list, function(x) replicate(999, simulate_Dplus_L(master.tax.list, tax.dist.sand, species = x)), simplify = FALSE)

stopCluster(core.clust) ## ALWAYS stop cluster afterwards!
rm(core.clust)

## fix the names of the list
names(dplus.l.sim) <- sim.list

## the list consists of 29 sub-lists, each with a matrix with 2 (named) rows - Dplus (odd) and Lambda (even) x 999 columns. Let's split them and make them presentable.
dplus.sim <- lapply(dplus.l.sim, function(x) x["Dplus", ])
dplus.sim.long <- stack(lapply(dplus.sim, unlist)) # unlist converts the sub-lists to vector, and stack puts them in a long data frame, adding a factor id column with original list item names
names(dplus.sim.long) <- c("Dplus_sim", "sp_number")

lambda.sim <- lapply(dplus.l.sim, function(x) x["Lambda", ])
lambda.sim.long <- stack(lapply(lambda.sim, unlist))
names(lambda.sim.long) <- c("Lambda_sim", "sp_number")
```

  Now plot the simulated D-plus & the confidence/tolerance intervlas to see if everything checks out - these will be also shown on the plot of real, observed data.
```{r conf_intervals_dplus}
## transform the simulated Dplus data frame into a tibble, and clean it a little
dplus.sim.long <- as_data_frame(dplus.sim.long) %>%
  mutate(sp_number = as.numeric(as.character(sp_number))) %>%
  arrange(sp_number)

## calculate the 95% confidence/tolerance intervals for each group (sp_number)
dplus.sim.conf.int <- dplus.sim.long %>% 
  group_by(sp_number) %>% 
  mutate(lower = tolerance::normtol.int(Dplus_sim, alpha = 0.05, P = 0.95, side = 2)$`2-sided.lower`, 
         upper = tolerance::normtol.int(Dplus_sim, alpha = 0.05, P = 0.95, side = 2)$`2-sided.upper`,
         average = mean(Dplus_sim))  

dplus.sim.conf.int <- dplus.sim.conf.int %>% 
  distinct(sp_number, lower, upper, average)

## plot this (just to check it out)
ggplot(dplus.sim.long, aes(x = sp_number, y = Dplus_sim)) + 
  geom_point(alpha = 0.25) + 
  geom_line(aes(x = sp_number, y = lower), data = dplus.sim.conf.int, color = "red") + 
  geom_line(aes(x = sp_number, y = upper), data = dplus.sim.conf.int, color = "red") + 
  geom_line(aes(x = sp_number, y = average), data = dplus.sim.conf.int, color = "red")

```
  Same for Lambda: 
```{r conf_int_lambda}
## transform the simulated Lambda data frame into a tibble, and clean & arrange it a little
lambda.sim.long <- as_data_frame(lambda.sim.long) %>%
  mutate(sp_number = as.numeric(as.character(sp_number))) %>%
  arrange(sp_number)

## calculate the 95% confidence/tolerance intervals for each group (sp_number)
lambda.sim.conf.int <- lambda.sim.long %>% 
  group_by(sp_number) %>% 
  mutate(lower = tolerance::normtol.int(Lambda_sim, alpha = 0.05, P = 0.95, side = 2)$`2-sided.lower`, 
         upper = tolerance::normtol.int(Lambda_sim, alpha = 0.05, P = 0.95, side = 2)$`2-sided.upper`, 
         average = mean(Lambda_sim))  

lambda.sim.conf.int <- lambda.sim.conf.int %>% 
  distinct(sp_number, lower, upper, average)

## plot this, too
ggplot(lambda.sim.long, aes(x = sp_number, y = Lambda_sim)) + 
  geom_point(alpha = 0.25) + 
  geom_line(aes(x = sp_number, y = lower), data = lambda.sim.conf.int, color = "red") + 
  geom_line(aes(x = sp_number, y = upper), data = lambda.sim.conf.int, color = "red") + 
  geom_line(aes(x = sp_number, y = average), data = lambda.sim.conf.int, color = "red")
```

  Now plot the real, observed values of D-plus in the sand dataset, and add these confidence limits.  
```{r plot_dplus_sand}
s.l.dplus.sand <- bind_cols(S = tax.distinctness.sand$Species, 
                            Dplus = tax.distinctness.sand$Dplus,
                            Lambda = tax.distinctness.sand$Lambda,
                            station = zoo.abnd.sand$station)

(plot.dplus.sand <- ggplot(s.l.dplus.sand, aes(x = S, y = Dplus, color = station)) +
    scale_color_brewer(palette = "Set2",
                       name = "Station", 
                       labels = paste0("S", as.numeric(unique(s.l.dplus.sand$station)))) +
    geom_point(alpha = 0.75, size = 2) +
    xlim(0, 100) + 
    geom_line(aes(x = sp_number, y = lower), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = upper), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = average), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3)
)

```
  And now plot the observed Lambda values, with the theoretical (simulated) confidence intervals.  
```{r plot_lambda_sand}
(plot.lambda.sand <- ggplot(s.l.dplus.sand, aes(x = S, y = Lambda, color = station)) +
   scale_color_brewer(palette = "Set2",
                      name = "Station",
                      labels = paste0("S", as.numeric(unique(s.l.dplus.sand$station)))) +
   geom_point(alpha = 0.75, size = 2) +
   xlim(0, 100) + 
   geom_line(aes(x = sp_number, y = lower), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3) + 
   geom_line(aes(x = sp_number, y = upper), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3) + 
   geom_line(aes(x = sp_number, y = average), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3)
)
```
  Most of the samples fall within the theoretical 95% confidence limits, and near the average theoretical values of both taxonomic distinctness indices - therefore do not deviate from expected taxonomic breadth & structure. Exception: several samples from Agalina (+ 1 from Chukalya, but I guess it's an anomaly) - lower Dplus & higher Lambda than expected - although not extremely so. This might suggest stressed communities where some senstitive higher taxa have disappeared. In the case of Agalina, it's more likely due to **natural stress** - because the station is located next to a natural reef from which it probably receives inputs of organic matter and various detritus (also observed during sample processing). In any case, there are no major anthropogenic sources of pressure in the area.  
  Note that half of the Sozopol (S4) samples have lower taxonomic spread than the average expected - that's because of the extreme dominance of *C. gallina* in the community. Still within the limits, though, so not indicative of any disturbance - just a natural consequence of this particular community structure.     
  
##### Graphical analyses  
  **Diversity profiles** are a graphical representation of the shape of the community. They show how the perceived diversity changes as the emphasis shifts from common to rare species - we can judge their respective contributions in the community composition.  
  Not sure if I'll use them in the thesis (most likely not), but I'm including the calculation and graphs here, because I think they're neat and I like them.  
```{r diversity_profiles_sand}
div.profiles.sand <- diversity_profiles(select(zoo.abnd.sand, -c(station:replicate)))

## plot them, too

```

  It's possible to calculate **weighted diversity profiles** by including a measure of similarity between species - for instance, taxonomic distance between them. This approach allows for a lot more meaningful ecological and biodiversity comparisons (Leinster & Cobbold, 2012).  
```{r weighted_diversity_profiles_sand}

```
  

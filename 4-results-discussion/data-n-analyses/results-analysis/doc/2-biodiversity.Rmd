---
title: "Biodiversity of macrozoobenthic communities - 2"
date: "2018-01-25"
output: 
  html_notebook:
    theme: paper
---

## Biodiversity, taxonomic distinctness & graphical community analyses  
This is a continuation of the community analyses started in part 1. Includes the selection of more sophisticated descriptive community analyses of biodiversity, again applied on the 3 separate datasets.  

*** 
  Some setup, to make this notebook stand-alone.
```{r setup, include = FALSE}
library(knitr)
knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(2, 2, .1, 2))  # smaller margin on top
})

## set the working directory to one up (all notebooks - kept in their own subdirectory within the project directory).
opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

## set knitr options for knitting code into the report.
opts_chunk$set(cache = TRUE, # save results so that code blocks aren't re-run unless code changes
               autodep = TRUE, # ..or unless a relevant earlier code block changed
               cache.comments = FALSE, # don't re-run if the only thing that changed was the comments
               highlight = TRUE, 
               small.mar = TRUE)
```
  Define the working subdirectories.
```{r workspace_setup}
## print the working directory, just to be on the safe side
paste("You are here: ", getwd())

data.dir <- "data"    # input data files
functions.dir <- "R"  # functions & scripts
save.dir <- "output"  # clean data, output from models & more complex calculations
figures.dir <- "figs" # plots & figures 
```
  Import functions.
```{r import_custom_functions}
source(file.path(functions.dir, "alpha_diversity.R"))
```
  
  Import the necessary libraries.  
```{r import_packages, message = FALSE}
library(here)
library(vegan)
library(tidyverse)
library(viridis)
```
  Organize some commonly-used ggplot2 modifications into a more convenient (and less repetitive) format.
```{r custom_ggplot_settings_helpers}
## ggplot settings & things that I keep reusing
# ggplot_theme <- list(
#   theme_bw(),
#   theme(element_text(family = "Times"))
# )
## always use black-and-white theme
theme_set(theme_bw())

## helper to adjust ggplot text size & avoid repetitions 
text_size <- function(text.x = NULL,
                      text.y = NULL,
                      title.x = NULL,
                      title.y = NULL,
                      legend.text = NULL,
                      legend.title = NULL, 
                      strip.x = NULL, 
                      strip.y = NULL) {
  theme(axis.text.x = element_text(size = text.x),
        axis.text.y = element_text(size = text.y),
        axis.title.x = element_text(size = title.x),
        axis.title.y = element_text(size = title.y),
        legend.text = element_text(size = legend.text), 
        legend.title = element_text(size = legend.title), 
        strip.text.x = element_text(size = strip.x), 
        strip.text.y = element_text(size = strip.y)
        )
  }
```
***
#### Macrozoobenthic communities in the sandy sediments of Burgas Bay (2013-2014)
Import the zoobenthic abundance & biomass data - as an exception, from the cleaned & saved datasets, to avoid (most of) the cleaning steps. 
```{r zoo_data_sand_import, message = FALSE, results = FALSE}
## dimensions should be 54 x 205 (5 metadata + 200 species columns); all species columns should be numeric.
zoo.abnd.sand <- read_csv(here::here(save.dir, "abnd_sand_orig_clean.csv"))

## same for biomass; same expected structure as the abundance
zoo.biomass.sand <- read_csv(here::here(save.dir, "biomass_sand_orig_clean.csv"))
```
  Convert columns to the proper type, arrange the datasets by station, etc.
```{r clean_zoo_data_sand, results = FALSE}
zoo.abnd.sand <- zoo.abnd.sand %>% 
  mutate(station = factor(station, levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva"))) %>%
  arrange(station, year, month)

zoo.biomass.sand <- zoo.biomass.sand %>% 
  mutate(station = factor(station, levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva"))) %>%
  arrange(station, year, month)
```
  Remove all species not present in the datasets (= all-0 columns). 
```{r clean_zoo_data_sand_2, results = FALSE}
## result should have dimensions 54 x 152 (147 species + 5 metadata columns) 
zoo.abnd.sand <- zoo.abnd.sand %>% 
  gather(key = species, value = sp_count, -c(station:replicate)) %>% 
  group_by(species) %>% 
  filter(sp_count > 0) %>%
  spread(species, sp_count, fill = 0) %>%
  arrange(station, year, month)

zoo.biomass.sand <- zoo.biomass.sand %>% 
  gather(key = species, value = sp_biomass, -c(station:replicate)) %>% 
  group_by(species) %>% 
  filter(sp_biomass > 0) %>%
  spread(species, sp_biomass, fill = 0) %>%
  arrange(station, year, month)
```
  Transform to long format, because for some functions it's better.  
```{r zoo_data_long_sand}
zoo.abnd.sand.long <- zoo.abnd.sand %>% 
  gather(key = species, value = sp_count, -c(station:replicate))

zoo.biomass.sand.long <- zoo.biomass.sand %>% 
  gather(key = species, value = sp_biomass, -c(station:replicate))
```

##### Alpha diversity indices  
All of the following can be calculated using package vegan. 
  + species richness S  
  + Shannon-Wiener biodiversity index H' (log2) - quantifies the probability that any two species drawn from the community are different - measure of entropy, NOT diversity! Therefore doesn't behave linearly. Actually measures the level of disorder in the system (more disorder = more diversity).    
  + Pielou evenness index J' - - level of dominance in the community. Close to 1 - the abundance is more evenly distrbuted among the species; close to 0 - one or several species largely dominate in abundance over the others.    
  + effective Shannon diversity (= corresponding Hill number) - to allow a meaningful comparison of diversity, not of entropy. Effective numbers impose a linear transformation on Shannon diversity - represent the number of equally abundant species necessary to produce the observed value of diversity. Range from 1 to S, where a value of S would indicate all species are present and in equal abundances.  
```{r alpha_diversity_sand}
## uses custom function for convenience - has to be imported first! 
alpha.div.sand <- zoo.abnd.sand %>%
  select(-c(station:replicate)) %>%
  alpha_diversity()

## add the metadata columns (row order is not changed, so possible) 
(alpha.div.sand <- bind_cols(zoo.abnd.sand %>% select(station:replicate), alpha.div.sand)
)
```
  Summarize these diversity indices by station & year.
```{r summarize_alpha_diversity_sand}
## might be a good place to eventually learn how to use the functions from package sjPlot for printing pretty (and easy!) tables...   
alpha.div.sand %>% 
  group_by(station, year) %>%
  summarise(h_mean = mean(shannon_h), h_sd = sd(shannon_h), 
            j_mean = mean(evenness_j), j_sd = sd(evenness_j),
            h_eff_mean = mean(h_effective), h_eff_sd = sd(h_effective)
            )
```
  
2. Species accumulation curves - see how species are added when the number of samples (sites) increases. Usually used to see if the sampling effort is adequate & captures most of the diversity in the study area.  
```{r sp_accumulation_curves_sand}
sac.sand <- specaccum(select(zoo.abnd.sand, -c(station:replicate)))

## extract data (temporarily) to plot in ggplot - easier to save afterwards with whatever parameters I want 
sac.data.sand <- as_data_frame(sac.sand[c("sites", "richness", "sd")])

## plot & save 
(plot.sac.sand <- ggplot(sac.data.sand) + 
    geom_line(aes(x = sites, y = richness), colour = "grey40") + 
    geom_ribbon(aes(x = sites, ymin = richness - sd, ymax = richness + sd), alpha = 0.3, fill = "skyblue") +
    ## add a line with slope 1 tangent to the accumulation curve - unfortunately, by eye, trial & error..  
    geom_abline(aes(intercept = 101, slope = 1), colour = "red", lty = 3) +
    
    labs(x = "Samples", y = "Cumulative number of species") + 
    text_size(text.x = rel(1.2), text.y = rel(1.2), title.x = rel(1.05), title.y = rel(1.05))
)

## save & clean up
ggsave(here(figures.dir, "sac_sand.png"), 
       plot.sac.sand, 
       width = 15, units = "cm", dpi = 300)

rm(sac.data.sand)
```
  About 30 samples seem to be enough to capture most of the biodiversity in the study area (in terms of species richness) - this is where the curve starts to smooth out (slope < 1). In my dataset, there are 54 samples in total - could be considered enough.  
  NB IF this method is applied correctly, since the samples are not independent but in fact represent replicates at each station.  
  
##### Species pool  
The species pool is the total extrapolated number of species in the study area (various estimates used here). Used to estimate the number of **unobserved species**. The functions assume that the number of unobserved species is related to he number of rare species (= seen only once or twice).     
```{r sp_pool_sand}
## this function is based on incidences in sample sites - presence/absence data; gives a single estimate for a collection of sample sites
specpool(select(zoo.abnd.sand, -c(station:replicate)), 
         pool = zoo.abnd.sand$station, 
         smallsample = TRUE)

## this function is quantitative - based on abundances on single sample site
estimateR(select(zoo.abnd.sand, -c(station:replicate)))
```
  Now let's do it for the whole dataset. 
```{r sp_pool_total_sand}
specpool(select(zoo.abnd.sand, -c(station:replicate)), 
         smallsample = TRUE)
```
  Looks good: based on the most severe estimate (second-order jacknife), the dataset captures about 77 % of the species pool, and based on the most forgiving one (bootstrap) - about 91 %.  
  
##### Taxonomic distance & diversity  
  Simple diversity measures do not distinguish between species. However, in the real world, species relationships (phylogenetic, taxonomic, functional..) matter, and could carry important ecologcial information.   
  We'll focus on the average tax.diversity based on presence/absence - Delta+, which reflects mean tax.breadth of the species lists, and Lambda+ - the variation in tax.distinctness, also based on presence/absence, which reflects unevenness in the tax.hierarchy.  
  For these analyses, a master species list for the whole study area is needed. For the Black Sea, it was compiled using the Catalogue of Black Sea Fauna & its 2 updates, as well as other, more recent inventories (full references & details in Materials & methods).  
```{r import_master_taxonomic_list}
## NB imported with row names on purpose, otherwise later some vegan functions fail! 
master.tax.list <- read.csv(file = file.path(data.dir, "td_zoo_taxonomy.csv"), header = TRUE, row.names = 1)
```
  Now we'll calculate the **taxonomic distance** for the dataset.
```{r tax_distance_sand}
## calculate the taxonomic distance for the master species list, using variable step - scaling according to reduction in number of classes when going up in the tax. tree (if almost all genera have only 1 species, it makes no big difference if 2 individuals belong to a different species or a different genus). 
tax.dist.sand <- taxa2dist(master.tax.list, varstep = TRUE)

## calculate the taxonomic distinctness indices for the abundance dataset, and print it to examine (its built-in print method is actually better than mine, after later conversions to tibble, etc.)
(tax.distinctness.sand <- taxondive(select(zoo.abnd.sand, -c(station:replicate)), tax.dist.sand)
)

## get the summary - includes a significance test on Delta+
summary(tax.distinctness.sand)

```
  Construct the 95% confidence funnels for the taxonomic distance using the master species list. Actually, these were probably meant to be 95% tolerance intervals (limits containing at least 95% of all observations), so that's what I'm going to calculate.  
  Thankfully, I can do this once for all three datasets - the simulation takes a lot of time and computational power.  
```{r simulate_tax_distance_indices}
sim.list <- seq(from = 10, to = 150, by = 5) 

simulate_Dplus_L <- function(master.list, tax.dist.mat, species) {
  ## helper calculating taxonomic distinctness indices Dplus and Lambda for a simulated community sampled at random from the master species list for the study area   
  
  ## simulate a possible community of the specified size from the master species list for the study area
  sim.community <- dplyr::sample_n(master.list, size = species, replace = FALSE)
  
  ## convert to a matrix, to use in vegan function taxondive 
  sim.community.mat <- matrix(1, nrow = 1, ncol = nrow(sim.community))
  colnames(sim.community.mat) <- row.names(sim.community)
  
  ## calculate & extract Dplus for the simulated community, suppressing the messages related to dimension mismatch with the master list 
  dplus.l <- suppressMessages(vegan::taxondive(sim.community.mat, tax.dist.mat)[c("Dplus", "Lambda")])
  
  return(dplus.l)
}

## generate the Dplus values for each simulated dataset - using the parallel version of sapply + replicate; ~11 min for 29000 values
library(parallel)
core.clust <- makeCluster(detectCores() - 2, type = "FORK") # make core cluster (leaving some threads for the other processes the computer is running), making sure to fork the environment, otherwise the functions won't be able to find objects in the global environment

dplus.l.sim <- parSapply(core.clust, sim.list, function(x) replicate(999, simulate_Dplus_L(master.tax.list, tax.dist.sand, species = x)), simplify = FALSE)

stopCluster(core.clust) ## ALWAYS stop cluster afterwards!
rm(core.clust)

## fix the names of the list
names(dplus.l.sim) <- sim.list

## the list consists of 29 sub-lists, each with a matrix with 2 (named) rows - Dplus (odd) and Lambda (even) x 999 columns. Let's split them and make them presentable.
dplus.sim <- lapply(dplus.l.sim, function(x) x["Dplus", ])
dplus.sim.long <- stack(lapply(dplus.sim, unlist)) # unlist converts the sub-lists to vector, and stack puts them in a long data frame, adding a factor id column with original list item names
names(dplus.sim.long) <- c("Dplus_sim", "sp_number")

lambda.sim <- lapply(dplus.l.sim, function(x) x["Lambda", ])
lambda.sim.long <- stack(lapply(lambda.sim, unlist))
names(lambda.sim.long) <- c("Lambda_sim", "sp_number")
```

  Now plot the simulated D-plus & the confidence/tolerance intervals to see if everything checks out - these will be also shown on the plot of real, observed data.
```{r conf_intervals_dplus}
## transform the simulated Dplus data frame into a tibble, and clean it a little
dplus.sim.long <- as_data_frame(dplus.sim.long) %>%
  mutate(sp_number = as.numeric(as.character(sp_number))) %>% # careful when converting factor to number!! have to print factor levels as character first, otherwise will get the corresponding integers!
  arrange(sp_number)

## calculate the 95% confidence/tolerance intervals for each group (sp_number)
dplus.sim.conf.int <- dplus.sim.long %>% 
  group_by(sp_number) %>% 
  mutate(lower = tolerance::normtol.int(Dplus_sim, alpha = 0.05, P = 0.95, side = 2)$`2-sided.lower`, 
         upper = tolerance::normtol.int(Dplus_sim, alpha = 0.05, P = 0.95, side = 2)$`2-sided.upper`,
         average = mean(Dplus_sim))  

dplus.sim.conf.int <- dplus.sim.conf.int %>% 
  distinct(sp_number, lower, upper, average)

## plot this (just to check it out)
ggplot(dplus.sim.long, aes(x = sp_number, y = Dplus_sim)) + 
  geom_point(alpha = 0.25) + 
  geom_line(aes(x = sp_number, y = lower), data = dplus.sim.conf.int, color = "red") + 
  geom_line(aes(x = sp_number, y = upper), data = dplus.sim.conf.int, color = "red") + 
  geom_line(aes(x = sp_number, y = average), data = dplus.sim.conf.int, color = "red")

```
  Same for Lambda: 
```{r conf_int_lambda}
## transform the simulated Lambda data frame into a tibble, and clean & arrange it a little
lambda.sim.long <- as_data_frame(lambda.sim.long) %>%
  mutate(sp_number = as.numeric(as.character(sp_number))) %>%
  arrange(sp_number)

## calculate the 95% confidence/tolerance intervals for each group (sp_number)
lambda.sim.conf.int <- lambda.sim.long %>% 
  group_by(sp_number) %>% 
  mutate(lower = tolerance::normtol.int(Lambda_sim, alpha = 0.05, P = 0.95, side = 2)$`2-sided.lower`, 
         upper = tolerance::normtol.int(Lambda_sim, alpha = 0.05, P = 0.95, side = 2)$`2-sided.upper`, 
         average = mean(Lambda_sim))  

lambda.sim.conf.int <- lambda.sim.conf.int %>% 
  distinct(sp_number, lower, upper, average)

## plot this, too
ggplot(lambda.sim.long, aes(x = sp_number, y = Lambda_sim)) + 
  geom_point(alpha = 0.25) + 
  geom_line(aes(x = sp_number, y = lower), data = lambda.sim.conf.int, color = "red") + 
  geom_line(aes(x = sp_number, y = upper), data = lambda.sim.conf.int, color = "red") + 
  geom_line(aes(x = sp_number, y = average), data = lambda.sim.conf.int, color = "red")
```
  Save the theoretical simulated Delta+ & Lambda+ - it takes 10 min to repeat otherwise.. 
```{r save_dplus_lambda_sim}
write_rds(list("Dplus_sim" = dplus.sim.long, 
               "Dplus_conf_int" = dplus.sim.conf.int, 
               "Lambda_sim" = lambda.sim.long, 
               "Lambda_conf_int" = lambda.sim.conf.int), 
          here(save.dir, "dplus_lambda_simulated.RDS"))
```

  Now plot the observed values of D-plus in the sand dataset, and add these confidence limits.  
```{r plot_dplus_sand}
s.l.dplus.sand <- bind_cols(S = tax.distinctness.sand$Species, 
                            Dplus = tax.distinctness.sand$Dplus,
                            Lambda = tax.distinctness.sand$Lambda,
                            station = zoo.abnd.sand$station)

plot.dplus.sand <- ggplot(s.l.dplus.sand, aes(x = S, y = Dplus, color = station)) +
  scale_color_brewer(palette = "Set2", 
                     labels = paste0("S", as.numeric(unique(s.l.dplus.sand$station)))) +
  geom_point(alpha = 0.75, size = 2) +
  xlim(0, 100) + 
  labs(x = "Number of species", y = expression(paste(Delta, "+"))) + 
  text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1.1), title.x = rel(1.1), title.y = rel(1.1), legend.title = rel(1.1))
  
## add confidence/tolerance lines
(plot.dplus.sand <- plot.dplus.sand + 
    geom_line(aes(x = sp_number, y = lower), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = upper), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = average), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3)
)

```
  And now plot the observed Lambda values, with the theoretical (simulated) confidence intervals.  
```{r plot_lambda_sand}
plot.lambda.sand <- ggplot(s.l.dplus.sand, aes(x = S, y = Lambda, color = station)) +
  scale_color_brewer(palette = "Set2",
                      labels = paste0("S", as.numeric(unique(s.l.dplus.sand$station)))) +
  geom_point(alpha = 0.75, size = 2) +
  xlim(0, 100) + 
  labs(x = "Number of species", y = expression(paste(Lambda, "+"))) +
  text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1.1), title.x = rel(1.1), title.y = rel(1.1), legend.title = rel(1.1))

## add the confidence/tolerance intervals
(plot.lambda.sand <- plot.lambda.sand + 
    geom_line(aes(x = sp_number, y = lower), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = upper), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = average), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3)
)

```
 
```{r plot_composite_dplus_lambda_sand}
## combine the 2 previous plots on one graph. They share a legend, so we'll jump through some (neccessary) hoops to put it at the bottom 

## plot them together in a grid
plot.dplus.l.combined.sand <- cowplot::plot_grid(plot.dplus.sand + theme(legend.position = "none"), 
                                                 plot.lambda.sand + theme(legend.position = "none"), 
                                                 labels = c("A", "B"), align = "h")

## get the legend from one of the plots, and put it at the bottom
dplus.legend <- cowplot::get_legend(plot.dplus.sand + theme(legend.position = "bottom"))

(plot.dplus.l.combined.sand <- cowplot::plot_grid(plot.dplus.l.combined.sand,
                                                  dplus.legend, 
                                                  ncol = 1, rel_heights = c(1, 0.2))
)

## save & clean up
cowplot::save_plot(here::here(figures.dir, "dplus_lambda_combined_sand.png"), 
                   plot.dplus.l.combined.sand, 
                   base_aspect_ratio = 0.9, base_width = 5.5, dpi = 300)

rm(dplus.legend)
```
  
  Most of the samples fall within the theoretical 95% confidence limits, and near the average theoretical values of both taxonomic distinctness indices - therefore do not deviate from expected taxonomic breadth & structure. Exception: several samples from S5 - Agalina (+ 1 from Chukalya, but I guess it's an anomaly) - lower Dplus & higher Lambda than expected - although not extremely so. This might suggest stressed communities where some senstitive higher taxa have disappeared. In the case of Agalina, it's more likely due to **natural stress** - because the station is located next to a natural reef from which it probably receives inputs of organic matter and various detritus (also observed during sample processing). In any case, there are no major anthropogenic sources of pressure in the area.  
  Note that half of the Sozopol (S4) samples have lower taxonomic spread than the average expected - that's because of the extreme dominance of *C. gallina* in the community. Still within the limits, though, so not indicative of any disturbance - just a natural consequence of this particular community structure.  
  
##### Graphical analyses  
###### **Diversity profiles**  
  Diversity profiles are a graphical representation of the shape of the community. They show how the perceived diversity changes as the emphasis shifts from common to rare species - we can judge their respective contributions in the community composition.  
  Not sure if I'll use them in the thesis (most likely not), but I'm including the calculation and graphs here, because I think they're neat and I like them.  
```{r diversity_profiles_sand}
div.profiles.sand <- diversity_profiles(zoo.abnd.sand %>% select(-c(station:replicate)))

## convert to long & add stations (manually, unfortunately)
div.profiles.sand.long <- div.profiles.sand %>%
  gather(key = id, value = value, -q) %>%
  mutate(id = gsub("V", "", id),
         station = case_when(id %in% as.character(1:9) ~ "Kraimorie", 
                             id %in% as.character(10:18) ~ "Chukalya", 
                             id %in% as.character(19:27) ~ "Akin", 
                             id %in% as.character(28:35) ~ "Sozopol", 
                             id %in% as.character(36:45) ~ "Agalina", 
                             id %in% as.character(46:54) ~ "Paraskeva"))

## convert profile id and station to factors, and q to numeric
(div.profiles.sand.long <- div.profiles.sand.long %>%
    mutate(station = factor(station, levels = levels(zoo.abnd.sand$station)), 
           id = factor(id, levels = 1:54), 
           q = as.numeric(q))
)

```
  Now plot them, just to see what they look like.  
```{r plot_diversity_profiles_sand}
plot_div_profiles <- function(div.profiles, one.panel = TRUE) {
  ## plots the diversity profiles by sampling station.
  ## Arguments: div.profiles - diversity profiles as data frame/tibble (long). 
  ##            one.panel - should the profiles for each station be plotted in 
  ##              a single panel (for example when average profiles only), or in
  ##              separate panels by station? Default - single panel.  
  ## Output: ggplot object.

  p <- ggplot(data = div.profiles, aes(x = q, y = value, group = id, colour = station)) +
    scale_color_brewer(palette = "Set2") + 
    labs(x = "Sensitivity parameter q", y = "Diversity") +
    scale_x_continuous(breaks = scales::pretty_breaks())

  if(!one.panel) {
    # plot the profiles in separate panels by station
    p <- p + geom_line() +  
      facet_wrap(~station) +
      theme(legend.position = "none")
  } else {
    # increase the line width to make the lines more visible  
    p <- p + geom_line(size = 0.7)
  }
  
  return(p)
}


plot_div_profiles(div.profiles.sand.long, one.panel = FALSE)

```
  Generally, the higher the profile, the higher the diversity - here, Agalina (S5) & Chukalya (S2) have the highest profiles overall.  
  It's better, however, to calculate **weighted diversity profiles** by including a measure of similarity between species - for instance, taxonomic distance between them. This approach allows for a lot more meaningful ecological and biodiversity comparisons (Leinster & Cobbold, 2012). The weighted diversity profiles are a community's "fingerprint".   
```{r weighted_diversity_profiles_sand}
## subset the large dist object (taxonomic distance b/n species) from before, to only the currently present species - in a very clumsy, very ugly way
tax.dist.sand.current <- as.matrix(tax.dist.sand)[which(rownames(as.matrix(tax.dist.sand)) %in% colnames(zoo.abnd.sand)), which(colnames(as.matrix(tax.dist.sand)) %in% colnames(zoo.abnd.sand))]


weighted.div.profiles.sand <- weighted_div_profiles(zoo.abnd.sand %>% select(-c(station:replicate)), 
                                                    tax.dist.sand.current, 
                                                    q = 50)

## convert to long, add stations & clean a little 
weighted.div.profiles.sand.long <- weighted.div.profiles.sand %>%
  gather(key = id, value = value, -q) %>%
  mutate(id = gsub("V", "", id),
         station = case_when(id %in% as.character(1:9) ~ "Kraimorie", 
                             id %in% as.character(10:18) ~ "Chukalya", 
                             id %in% as.character(19:27) ~ "Akin", 
                             id %in% as.character(28:35) ~ "Sozopol", 
                             id %in% as.character(36:45) ~ "Agalina", 
                             id %in% as.character(46:54) ~ "Paraskeva"))

## convert profile id and station to factors, and q to numeric
(weighted.div.profiles.sand.long <- weighted.div.profiles.sand.long %>%
    mutate(station = factor(station, levels = levels(zoo.abnd.sand$station)), 
           id = factor(id, levels = 1:54), 
           q = as.numeric(q))
)

plot_div_profiles(weighted.div.profiles.sand.long, one.panel = F)
```
  Now, it's more clearly apparent: Chukalya & Agalina have the most diverse communities; then - Kraimorie, Akin & Paraskeva; and Sozopol has the lowest effective diversity. Agalina & Paraskeva also have several "atypical" samples with many rare species - whose profiles drop very sharply for 0 < q < 1.  
  Let's calculate the average diversity profiles by station, because these plots are very busy, and plot everything more cleanly.  
```{r average_weighted_div_profiles_sand}
(aver.weighted.div.profiles.sand <- weighted.div.profiles.sand.long %>% 
   group_by(station, q) %>%
   summarise(value = mean(value))
)
```
  
```{r plot_weighted_div_profiles_sand}
ggplot(aver.weighted.div.profiles.sand, 
       aes(x = q, y = value, colour = station)) + 
  geom_line(lwd = 0.75) +
  scale_color_brewer(palette = "Set2", 
                     labels = paste0("S", as.numeric(unique(aver.weighted.div.profiles.sand$station))))+ 
  labs(x = "Sensitivity parameter q", y = "Diversity")
 
```
  Same conclusion as above.  
  
###### **ABC curves**  
  These are cumulative k-dominance curves plotted from the species abundance distribution and the species biomass distribution -> y-axis scale: 0 to 100. Used to determine visually the level of disturbance of the communities. Under stable conditions, the competitive dominants in the communities are K-strategists - large-bodied, conservative species with long life-span, usually dominant in terms of biomass; when the communities suffer a perturbation, the smaller, opportunistic species are favored - small body size and short life-span, can be numerically significant, but rarely represent a large proportion of the biomass. Thus, under undisturbed conditions, the biomass curve is elevated over the abundance curve; under moderate disturbance, the biomass and the abundance curves are coincident and may cross each other one or several times; under severe disturbance, the abundance curve lies above the biomass curve throughout its length.  
  First, we'll calculate them on each replicate separately:
```{r abc_sand}
(abc.sand <- abc(zoo.abnd.sand.long, zoo.biomass.sand.long, 
                 abnd.val = sp_count, biomass.val = sp_biomass, 
                 station, year, month, replicate)
)
## result is a list: 1) grouped df containing the curves (long), 2) summarized df with the W statistic per replicate - the distance between the 2 curves  

```
  
  We'll plot W, because there are too many stations & replicates and the curves will be unreadable.   
```{r plot_w_sand}
ggplot(abc.sand[[2]], aes(x = station, y = w, colour = factor(year))) + 
  geom_boxplot() + 
  scale_x_discrete(name = "Station", 
                   labels = paste0("S", as.numeric(unique(abc.sand[[2]]$station)))) + 
  ylab("W") + 
  theme(legend.title = element_blank()) +
  geom_hline(yintercept = 0)
```

  W > 0 for all samples => the biomass curve is above the abundance curve, so none of the stations/replicates can be considered terribly disturbed. The closer to 0 the statistic gets, the closer the 2 curves are; here, S5-Agalina comes closest, but still not too close. Nowhere is there complete dominance of one species in the biomass, perfectly even distribution of the abundance among species (W = 1, or tending towards it), nor the opposite (W = -1). In short, the structure of the communities is more or less even and normal, with variations characteristic of macrozoobenthic samples/communities. 
  For S1, S2, S5, S6, W decreases somewhat between 2013-2014. There were less samples in 2014, but still, there might be some disturbance -> perhaps due to the heavy rains in the summer of 2014, esp. for S5-6 which were sampled immediately afterwards (although not really enough time for the communities to react, in my opinion - but will keep in mind just in case).  
  
  Let's plot the summary ABC curves - per station and year. 2 rows (for the 2 years) + 6 columns (stations) in the plot - will put it in landscape format in the text.  
  The summary curves will be calculated on **data averaged by year** - this way, there will hopefully be enough replication to reduce the over-dominance of large mollusks etc. in the biomass (they are rarely dominant in the abundance - more often represented by 1-2 individuals/sample).  
```{r summarize_abnd_biomass_sand}
## summarize the abundance and biomass data per year (average)  
(summary.abnd.sand <- zoo.abnd.sand.long %>%
   group_by(station, year, species) %>%
   summarize(mean_count = mean(sp_count))
)

(summary.biomass.sand <- zoo.biomass.sand.long %>%
   group_by(station, year, species) %>%
   summarize(mean_biomass = mean(sp_biomass))
)
```
  Now calculate the summary ABC for 2013 and 2014 for the sand stations.  
```{r summary_abc_sand}
(abc.summary.sand <- abc(summary.abnd.sand, summary.biomass.sand, 
                         abnd.val = mean_count, biomass.val = mean_biomass, 
                         station, year)
)
```
  All good, let's plot these!   
  Very often, the curves approach a cumulative frequency of 100 % for a large part of their length, esp. in highly dominated communities - often after the first 2-3 top-ranked species, making the forms of the abundance and biomass curves difficult to distinguish. We can transform the y-axis so that the cumulative values are closer to linearity - e.g. using a modified logistic transformation (Clarke & Warwick 2001).  
```{r ggplot_modif_logistic_transform}
## define a custom transformation and its inverse for the y axis (modified logistic transformation) using the scales package (for ggplot graphics).
modif_logistic_trans <- function() scales::trans_new("modif_logistic", 
                                                     function(x) log((1 + x)/(101 - x)), 
                                                     function(x) exp((1 + x)/(101 - x)))

```

```{r plot_summary_abc_sand}
## reshape the data for easier plotting - and to have a legend..
abc.summary.sand.long <- abc.summary.sand[[1]] %>% 
  gather(key = variable, value = value, -c(station:sp_rank)) %>%
  mutate(variable = case_when(variable == "cum_abnd" ~ "abundance", 
                              variable == "cum_biomass" ~ "biomass"))

## make named character vector for the custom station labels   
stations.sand <- paste0("S", as.numeric(unique(abc.summary.sand[[1]]$station)))
names(stations.sand) <- as.character(unique(abc.summary.sand[[1]]$station))

## plot 
plot.summary.abc.sand <- ggplot(abc.summary.sand.long, 
                                aes(x = sp_rank, y = value, colour = variable)) + 
  geom_line() + 
  # apply axis transformations 
  scale_x_log10() +
  coord_trans(y = "modif_logistic")  + 
  # curve colours and legend 
  scale_colour_manual(values = c("skyblue", "orange"), name = "") + 
  theme(legend.position = "top") + 
  # facets & labels
  facet_grid(year ~ station, labeller = labeller(station = as_labeller(stations.sand))) + 
  labs(x = "Species rank (log)", y = "Cumulative %")

## modify text size a little 
(plot.summary.abc.sand <- plot.summary.abc.sand + text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1), title.x = rel(1.1), title.y = rel(1.1), strip.x = rel(1.1), strip.y = rel(1.1))
)

## and save this - huge, because I think it will be displayed best as a whole-page graph.. 
ggsave(here::here(figures.dir, "summary_abc_sand.png"), 
       plot.summary.abc.sand, 
       width = 25, height = 15, units = "cm", dpi = 300)

rm(abc.summary.sand.long)
```
  General conclusions still the same: overall, biomass curve above abundance curve everywhere; slightly worse condition of the communities in 2014 (curves closer to one another for more stations); no change at some stations (S3-Akin, S4-Sozopol, S6-Paraskeva). Otherwise, results seem to follow gradient more or less - curves closer to one another at inner stations, wider apart at outer ones; exception - S5-Agalina - arguably the worst - but again, probably naturally "stressed" - no major pressure sources nearby..   
  
###### **Partial dominance curves**  
  Used in order to avoid problems of over-dominance of species affecting the curves and their interpretation. Partial dominance curves compute the dominance of the second ranked species over the remainder, ignoring the first-ranked species, and so on with the remaining species. Thus, earlier values do not affect later points on the curve. Partial dominance ABC curves for undisturbed macrobenthic communities have the biomass curve over the abundance curve (mostly) throughout its length. The abundance curve is smoother; the biomass curve shows a slight and steady decline before its inevitable final rise. Under polluted conditions, there is still a change in position of partial dominance curves, and the abundance curve is much more "ragged": the implication is that the disturbance is affecting the whole suite of species in the community (Clarke & Warwick 2001).  
```{r partial_dominance_sand}
## will be calculated directly on the summarized abundance/biomass data
(pd.summary.sand <- partial_dominance_curves(summary.abnd.sand, summary.biomass.sand, 
                                            abnd.val = mean_count, biomass.val = mean_biomass, 
                                            station, year)
)
```

  Let's see what this looks like (and if it's any improvement over the regular ABS curves)..  
```{r plot_partial_dominance_sand}
## reshape the data as before..
pd.summary.sand.long <- pd.summary.sand %>% 
  gather(key = variable, value = value, -c(station:sp_rank)) %>%
  mutate(variable = case_when(variable == "partial_abnd" ~ "abundance", 
                              variable == "partial_biomass" ~ "biomass"))

## plot
plot.pd.sand <- ggplot(pd.summary.sand.long, aes(x = sp_rank, y = value, colour = variable)) + 
  geom_line() + 
  # apply axis transformations 
  scale_x_log10() +
  # curve colours and legend 
  scale_colour_manual(values = c("skyblue", "orange"), name = "") + 
  theme(legend.position = "top") + 
  # facets & labels
  facet_grid(year ~ station, labeller = labeller(station = as_labeller(stations.sand))) + 
  labs(x = "Species rank (log)", y = "%")

## modify text size a little
(plot.pd.sand <- plot.pd.sand + text_size(text.x = rel(1.2), text.y = rel(1.2), title.x = rel(1.1), title.y = rel(1.1), strip.x = rel(1.1), strip.y = rel(1.1))
)

## save, just in case, although I don't much see the point in using ALL of them, when they're showing basically the same thing..
ggsave(here::here(figures.dir, "summary_pd_sand.png"), 
       plot.pd.sand, 
       width = 25, height = 15, units = "cm", dpi = 300)

rm(pd.summary.sand.long)
```
  More or less the same pattern.. Slight apparent worsening of the community structure in 2014; S5-Agalina - the most disturbed (curves instersect several times and are closest together, as well as somewhat ragged). Interesting - S4-Sozopol (and S6-Paraskeva, a little) - the dominance of the clam *C. gallina* is very clear from the curves - sharp drop of the biomass & abundance after the first-ranked species.    


#### Macrozoobenthic communities in the seagrasses of Burgas Bay (2013-2014)
Import the abundance & biomass data - again, from the cleaned & saved datasets, to avoid (most of) the cleaning steps. 
```{r zoo_data_zostera_import, message = FALSE, results = FALSE}
## dimensions should be 32 x 205 (5 metadata + 200 species columns); all species columns should be numeric.
zoo.abnd.zostera <- read_csv(here::here(save.dir, "abnd_zostera_orig_clean.csv"))

## same for biomass; same expected structure as the abundance
zoo.biomass.zostera <- read_csv(here::here(save.dir, "biomass_zostera_orig_clean.csv"))
```
  Convert columns to the proper type, arrange the datasets by station, etc.
```{r clean_zoo_data_zostera, results = FALSE}
zoo.abnd.zostera <- zoo.abnd.zostera %>% 
  mutate(station = factor(station, levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo"))) %>%
  arrange(station, year, month)

zoo.biomass.zostera <- zoo.biomass.zostera %>% 
  mutate(station = factor(station, levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo"))) %>%
  arrange(station, year, month)
```
  Remove all species not present in the datasets (= all-0 columns). 
```{r clean_zoo_data_zostera_2, results = FALSE}
## result should have dimensions 32 x 99 (94 species + 5 metadata columns) 
zoo.abnd.zostera <- zoo.abnd.zostera %>% 
  gather(key = species, value = sp_count, -c(station:replicate)) %>% 
  group_by(species) %>% 
  filter(sp_count > 0) %>%
  spread(species, sp_count, fill = 0) %>%
  arrange(station, year, month)

zoo.biomass.zostera <- zoo.biomass.zostera %>% 
  gather(key = species, value = sp_biomass, -c(station:replicate)) %>% 
  group_by(species) %>% 
  filter(sp_biomass > 0) %>%
  spread(species, sp_biomass, fill = 0) %>%
  arrange(station, year, month)
```
  Transform to long format.  
```{r zoo_data_long_zostera}
zoo.abnd.zostera.long <- zoo.abnd.zostera %>% 
  gather(key = species, value = sp_count, -c(station:replicate))

zoo.biomass.zostera.long <- zoo.biomass.zostera %>% 
  gather(key = species, value = sp_biomass, -c(station:replicate))
```
  
##### Alpha diversity indices  

```{r alpha_diversity_zostera}
## uses custom function for convenience - has to be imported first! 
alpha.div.zostera <- zoo.abnd.zostera %>%
  select(-c(station:replicate)) %>%
  alpha_diversity()

## add the metadata columns (row order is not changed, so possible) 
(alpha.div.zostera <- bind_cols(zoo.abnd.zostera %>% select(station:replicate), alpha.div.zostera)
)
```
  Summarize these diversity indices by station & year.
```{r summarize_alpha_diversity_zostera}
## STILL haven't learned how to use the functions from package sjPlot for printing pretty (and easy!) tables...   
alpha.div.zostera %>% 
  group_by(station, year) %>%
  summarise(h_mean = mean(shannon_h), h_sd = sd(shannon_h), 
            j_mean = mean(evenness_j), j_sd = sd(evenness_j),
            h_eff_mean = mean(h_effective), h_eff_sd = sd(h_effective)
            )
```
  
  2. Species accumulation curves - see how species are added when the number of samples (sites) increases. Usually used to see if the sampling effort is adequate & captures most of the diversity in the study area.  
```{r sp_accumulation_curves_zostera}
sac.zostera <- specaccum(select(zoo.abnd.zostera, -c(station:replicate)))

## extract data (temporarily) to plot in ggplot
sac.data.zostera <- as_data_frame(sac.zostera[c("sites", "richness", "sd")])

## plot & save 
(plot.sac.zostera <- ggplot(sac.data.zostera) + 
    geom_line(aes(x = sites, y = richness), colour = "grey40") + 
    geom_ribbon(aes(x = sites, ymin = richness - sd, ymax = richness + sd), alpha = 0.3, fill = "skyblue") +
    ## add a line with slope 1 tangent to the accumulation curve - unfortunately, by eye, trial & error..  
    geom_abline(aes(intercept = 65, slope = 1), colour = "red", lty = 3) +
    labs(x = "Samples", y = "Cumulative number of species") + 
    text_size(text.x = rel(1.2), text.y = rel(1.2), title.x = rel(1.05), title.y = rel(1.05))
)

## save & clean up
ggsave(here(figures.dir, "sac_zostera.png"), 
       plot.sac.zostera, 
       width = 15, units = "cm", dpi = 300)

rm(sac.data.zostera)
```
  Again, about 20 (maybe a little more) samples seem to be enough to capture most of the biodiversity in the study area (in terms of species richness) - this is where the curve starts to smooth out (slope < 1). In my seagrass dataset, there are 32 samples in total - let's say that's about enough..  
  NB IF this method is applied correctly, since the samples are not independent but in fact represent replicates at each station..   
  
##### Species pool  
The species pool is the total extrapolated number of species in the study area (various estimates used here). Used to estimate the number of **unobserved species**. The functions assume that the number of unobserved species is related to he number of rare species (= seen only once or twice).     
```{r sp_pool_zostera}
## this function is based on incidences in sample sites - presence/absence data; gives a single estimate for a collection of sample sites
specpool(select(zoo.abnd.zostera, -c(station:replicate)), 
         pool = zoo.abnd.zostera$station, 
         smallsample = TRUE)

## this function is quantitative - based on abundances on single sample site
estimateR(select(zoo.abnd.zostera, -c(station:replicate)))
```
  Now let's do it for the whole dataset. 
```{r sp_pool_total_zostera}
specpool(select(zoo.abnd.zostera, -c(station:replicate)), 
         smallsample = TRUE)
```
  Looks good enough: based on the most severe estimate (second-order jacknife), the dataset captures about 76 % of the species pool, and based on the most forgiving one (bootstrap) - about 91 %. Not too bad, considering that some sites are underrepresented..   
  
##### Taxonomic distance & diversity  
  No need to redo all the master list/simulated community calculations as before - they're valid for the seagrasses, too.  
  Calculate the **taxonomic distance** for the seagrass zoobenthic communities.  
```{r tax_distance_zostera}
## we'll use the same taxonomic distance for the master species list as before

## calculate the taxonomic distinctness indices for the abundance dataset
(tax.distinctness.zostera <- taxondive(select(zoo.abnd.zostera, -c(station:replicate)), tax.dist.sand)
)

## get the summary - includes a significance test on Delta+
summary(tax.distinctness.zostera)

```
  Huh, not even a single significant p-value.. How sweet.  
  Now plot the real, observed values of D-plus in the seagrass dataset, and add these confidence limits.  
```{r plot_dplus_zostera}
s.l.dplus.zostera <- bind_cols(S = tax.distinctness.zostera$Species,
                               Dplus = tax.distinctness.zostera$Dplus,
                               Lambda = tax.distinctness.zostera$Lambda,
                               station = zoo.abnd.zostera$station)

plot.dplus.zostera <- ggplot(s.l.dplus.zostera, aes(x = S, y = Dplus, color = station)) +
  scale_color_brewer(palette = "Set2", 
                     labels = paste0("Z", as.numeric(unique(s.l.dplus.zostera$station)))) +
  geom_point(alpha = 0.85, size = 2) +
  xlim(0, 100) + 
  labs(x = "Number of species", y = expression(paste(Delta, "+"))) + 
  text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1.1), title.x = rel(1.1), title.y = rel(1.1), legend.title = rel(1.1))
  
## add confidence/tolerance lines
(plot.dplus.zostera <- plot.dplus.zostera + 
    geom_line(aes(x = sp_number, y = lower), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = upper), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = average), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3)
)

```
  And now plot the observed Lambda values, with the theoretical (simulated) confidence intervals.  
```{r plot_lambda_zostera}
plot.lambda.zostera <- ggplot(s.l.dplus.zostera, aes(x = S, y = Lambda, color = station)) +
  scale_color_brewer(palette = "Set2",
                      labels = paste0("Z", as.numeric(unique(s.l.dplus.zostera$station)))) +
  geom_point(alpha = 0.85, size = 2) +
  xlim(0, 100) + 
  labs(x = "Number of species", y = expression(paste(Lambda, "+"))) +
  text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1.1), title.x = rel(1.1), title.y = rel(1.1), legend.title = rel(1.1))

## add the confidence/tolerance intervals
(plot.lambda.zostera <- plot.lambda.zostera + 
    geom_line(aes(x = sp_number, y = lower), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = upper), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = average), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3)
)

```
 
```{r plot_composite_dplus_lambda_zostera}
## combine the 2 previous plots on one graph. They share a legend, so we'll jump through some (neccessary) hoops to put it at the bottom 

## plot them together in a grid
plot.dplus.l.combined.zostera <- cowplot::plot_grid(plot.dplus.zostera + theme(legend.position = "none"), 
                                                 plot.lambda.zostera + theme(legend.position = "none"), 
                                                 labels = c("A", "B"), align = "h")

## get the legend from one of the plots, and put it at the bottom
dplus.legend <- cowplot::get_legend(plot.dplus.zostera + theme(legend.position = "bottom"))

(plot.dplus.l.combined.zostera <- cowplot::plot_grid(plot.dplus.l.combined.zostera,
                                                  dplus.legend, 
                                                  ncol = 1, rel_heights = c(1, 0.2))
)

## save & clean up
cowplot::save_plot(here::here(figures.dir, "dplus_lambda_combined_zostera.png"), 
                   plot.dplus.l.combined.zostera, 
                   base_aspect_ratio = 0.9, base_width = 5.5, dpi = 300)

rm(dplus.legend)
```
  
  All of the samples fall within the theoretical 95% confidence limits, and near the average theoretical values of both taxonomic distinctness indices - therefore do not deviate from expected taxonomic breadth & structure. This confirms the lack of significant values in the z-test above (-> no difference in observed taxonomic structure than expected).  
  
##### Graphical analyses  
###### **Diversity profiles**  
 Included more for the sake of completeness than for any other reason.   
```{r diversity_profiles_zostera}
div.profiles.zostera <- diversity_profiles(zoo.abnd.zostera %>% select(-c(station:replicate)))

## convert to long & add stations (manually, unfortunately)
div.profiles.zostera.long <- div.profiles.zostera %>%
  gather(key = id, value = value, -q) %>%
  mutate(id = gsub("V", "", id),
         station = case_when(id %in% as.character(1:8) ~ "Poda", 
                             id %in% as.character(9:16) ~ "Otmanli", 
                             id %in% as.character(17:20) ~ "Vromos", 
                             id %in% as.character(21:28) ~ "Gradina", 
                             id %in% as.character(29:32) ~ "Ropotamo"))

## convert profile id and station to factors, and q to numeric
(div.profiles.zostera.long <- div.profiles.zostera.long %>%
    mutate(station = factor(station, levels = levels(zoo.abnd.zostera$station)), 
           id = factor(id, levels = 1:54), 
           q = as.numeric(q))
)

```
  Now plot them, just to see what they look like.  
```{r plot_diversity_profiles_zostera}
plot_div_profiles(div.profiles.zostera.long, one.panel = FALSE)

```
  Here, Gradina (Z4), Otmanli (Z2) & Ropotamo (Z5) seem to have the highest profiles (= highest diversity) overall.  
  Calculate the **weighted diversity profiles** by including a measure of similarity between species - here, again, the taxonomic distance between them. 
```{r weighted_diversity_profiles_zostera}
## subset the large dist object (taxonomic distance b/n species) from before, to only the currently present species - in a very clumsy, very ugly way
tax.dist.zostera.current <- as.matrix(tax.dist.sand)[which(rownames(as.matrix(tax.dist.sand)) %in% colnames(zoo.abnd.zostera)), which(colnames(as.matrix(tax.dist.sand)) %in% colnames(zoo.abnd.zostera))]


weighted.div.profiles.zostera <- weighted_div_profiles(zoo.abnd.zostera %>% select(-c(station:replicate)), 
                                                       tax.dist.zostera.current, q = 50)

## convert to long, add stations & clean a little (as before)
weighted.div.profiles.zostera.long <- weighted.div.profiles.zostera %>%
  gather(key = id, value = value, -q) %>%
  mutate(id = gsub("V", "", id),
         station = case_when(id %in% as.character(1:8) ~ "Poda", 
                             id %in% as.character(9:16) ~ "Otmanli", 
                             id %in% as.character(17:20) ~ "Vromos", 
                             id %in% as.character(21:28) ~ "Gradina", 
                             id %in% as.character(29:32) ~ "Ropotamo"))

## convert profile id and station to factors, and q to numeric
(weighted.div.profiles.zostera.long <- weighted.div.profiles.zostera.long %>%
    mutate(station = factor(station, levels = levels(zoo.abnd.zostera$station)), 
           id = factor(id, levels = 1:54), 
           q = as.numeric(q))
)

plot_div_profiles(weighted.div.profiles.zostera.long, one.panel = FALSE)
```
  Now, it's more clearly apparent: Gradina, Otmanli & Ropotamo have the most diverse communities. However, there is high variability between samples from the same station - very obvious e.g. for Gradina.    
  Let's calculate the average diversity profiles by station, because these last plots are very busy, it's hard to distinguish anything.    
```{r average_weighted_div_profiles_zostera}
(aver.weighted.div.profiles.zostera <- weighted.div.profiles.zostera.long %>% 
   group_by(station, q) %>%
   summarise(value = mean(value))
)
```
  
```{r plot_weighted_div_profiles_zostera}
ggplot(aver.weighted.div.profiles.zostera, 
       aes(x = q, y = value, colour = station)) + 
  geom_line(lwd = 0.75) +
  scale_color_brewer(palette = "Set2", 
                     labels = paste0("Z", as.numeric(unique(aver.weighted.div.profiles.zostera$station))))+ 
  labs(x = "Sensitivity parameter q", y = "Diversity")
 
```
  Same conclusion as above. Also, Z1-Poda drops sharply - suggests presence of rare species & lower diversity.  
  
###### **ABC curves**  
  First, we'll calculate them on each replicate separately:
```{r abc_zostera}
(abc.zostera <- abc(zoo.abnd.zostera.long, zoo.biomass.zostera.long, 
                 abnd.val = sp_count, biomass.val = sp_biomass, 
                 station, year, month, replicate)
)
## result is a list: 1) grouped df containing the curves (long), 2) summarized df with the W statistic per replicate - the distance between the 2 curves  

```
  
  We'll plot W, because there are too many stations & replicates and the curves will be unreadable.   
```{r plot_w_zostera}
ggplot(abc.zostera[[2]], aes(x = station, y = w, colour = factor(year))) + 
  geom_boxplot() + 
  scale_x_discrete(name = "Station", 
                   labels = paste0("Z", as.numeric(unique(abc.zostera[[2]]$station)))) + 
  ylab("W") + 
  theme(legend.title = element_blank()) +
  geom_hline(yintercept = 0)
```

  W > 0 for most samples except Vromos => the biomass curve is above the abundance curve, so none of the stations/replicates can be considered terribly disturbed. The mean W for Z3-Vromos is still above 0, but some of the samples are below => the curves are close together, suggesting disturbance. Not really very surprising, because 1) Vromos was close to an untreated sewage water source, and 2) there are less samples than for the other stations. Again, there is no evidence for complete dominance of one species in the biomass, perfectly even distribution of the abundance among species (W = 1, or tending towards it), nor the opposite (W = -1). In short, the structure of the communities is more or less even and normal, with variations characteristic of macrozoobenthic samples/communities. 
  For Z2 & Z4, W decreases somewhat between 2013-2014. There might be some disturbance -> perhaps due to the heavy rains in the summer of 2014 - something to keep in mind just in case (again, prob. not enough time for the communities to display a reaction).  
  
  Plot the summary ABC curves - per station and year. 2 rows (for the 2 years) + 5 columns (stations) in the plot - will put it in landscape format in the text.  
  The summary curves will be calculated on **data averaged by year** - again, to reduce the over-dominance of large mollusks etc. in the biomass.  
```{r summarize_abnd_biomass_zostera}
## summarize the abundance and biomass data per year (average)  
(summary.abnd.zostera <- zoo.abnd.zostera.long %>%
   group_by(station, year, species) %>%
   summarize(mean_count = mean(sp_count))
)

(summary.biomass.zostera <- zoo.biomass.zostera.long %>%
   group_by(station, year, species) %>%
   summarize(mean_biomass = mean(sp_biomass))
)
```
  Now calculate the summary ABC for 2013 and 2014 for the zostera stations.  
```{r summary_abc_zostera}
(abc.summary.zostera <- abc(summary.abnd.zostera, summary.biomass.zostera, 
                         abnd.val = mean_count, biomass.val = mean_biomass, 
                         station, year)
)
```
  All good, let's plot them!   
```{r plot_summary_abc_zostera}
## reshape the data for easier plotting - and to have a legend..
abc.summary.zostera.long <- abc.summary.zostera[[1]] %>% 
  gather(key = variable, value = value, -c(station:sp_rank)) %>%
  mutate(variable = case_when(variable == "cum_abnd" ~ "abundance", 
                              variable == "cum_biomass" ~ "biomass"))

## make named character vector for the custom station labels   
stations.zostera <- paste0("Z", as.numeric(unique(abc.summary.zostera[[1]]$station)))
names(stations.zostera) <- as.character(unique(abc.summary.zostera[[1]]$station))

## plot 
plot.summary.abc.zostera <- ggplot(abc.summary.zostera.long, 
                                aes(x = sp_rank, y = value, colour = variable)) + 
  geom_line() + 
  # apply axis transformations 
  scale_x_log10() +
  coord_trans(y = "modif_logistic")  + 
  # curve colours and legend 
  scale_colour_manual(values = c("skyblue", "orange"), name = "") + 
  theme(legend.position = "top") + 
  # facets & labels
  facet_grid(year ~ station, labeller = labeller(station = as_labeller(stations.zostera))) + 
  labs(x = "Species rank (log)", y = "Cumulative %")

## modify text size a little 
(plot.summary.abc.zostera <- plot.summary.abc.zostera + text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1), title.x = rel(1.1), title.y = rel(1.1), strip.x = rel(1.1), strip.y = rel(1.1))
)

## and save this - huge, because I think it will be displayed best as a whole-page graph.. 
ggsave(here::here(figures.dir, "summary_abc_zostera.png"), 
       plot.summary.abc.zostera, 
       width = 25, height = 15, units = "cm", dpi = 300)

rm(abc.summary.zostera.long)
```
  Overall, the biomass curve is above the abundance curve almost everywhere, with some exceptions: Z3-Vromos - as suggested by W; Z4-Gradina in 2014. The curves otherwise are very close together - indicative of a slight disturbance. Very characteristic of seagrass communities - appear disturbed because of the high natural organic loading (-> tolerant r-strategist species present even in the most pristine conditions). Must be taken into account when applying biotic indices - they will most likely function incorrectly!   
  Results do not follow the pressure gradient at all - the curves at all stations are close to one another.  
  Of course, another contributing factor could be insufficient replication which might hide dominance patterns...  
  
###### **Partial dominance curves**  

```{r partial_dominance_zostera}
## will be calculated directly on the summarized abundance/biomass data
(pd.summary.zostera <- partial_dominance_curves(summary.abnd.zostera, summary.biomass.zostera, 
                                                abnd.val = mean_count, biomass.val = mean_biomass, 
                                                station, year)
)
```

```{r plot_partial_dominance_zostera}
## reshape the data as before..
pd.summary.zostera.long <- pd.summary.zostera %>% 
  gather(key = variable, value = value, -c(station:sp_rank)) %>%
  mutate(variable = case_when(variable == "partial_abnd" ~ "abundance", 
                              variable == "partial_biomass" ~ "biomass"))

## plot
plot.pd.zostera <- ggplot(pd.summary.zostera.long, aes(x = sp_rank, y = value, colour = variable)) + 
  geom_line() + 
  # apply axis transformations 
  scale_x_log10() +
  # curve colours and legend 
  scale_colour_manual(values = c("skyblue", "orange"), name = "") + 
  theme(legend.position = "top") + 
  # facets & labels
  facet_grid(year ~ station, labeller = labeller(station = as_labeller(stations.zostera))) + 
  labs(x = "Species rank (log)", y = "%")

## modify text size a little
(plot.pd.zostera <- plot.pd.zostera + text_size(text.x = rel(1.2), text.y = rel(1.2), title.x = rel(1.1), title.y = rel(1.1), strip.x = rel(1.1), strip.y = rel(1.1))
)

## save, just in case, although I don't much see the point in using ALL of them, when they're showing basically the same thing..
ggsave(here::here(figures.dir, "summary_pd_zostera.png"), 
       plot.pd.zostera, 
       width = 25, height = 15, units = "cm", dpi = 300)

rm(pd.summary.zostera.long)
```
  More or less the same pattern.. Interesting - compared to the partial dominance curves in the sand samples - much less dominance (both curves start at about the same level). There is also more variability - probably because the samples are smaller (taken with a corer) and fewer.  
  

#### Macrozoobenthic communities in seagrass and sand in Sozopol Bay (2012)   
Import the abundance & biomass data - again, from the cleaned & saved datasets, to avoid (most of) the cleaning steps. 
```{r zoo_data_2012_import, message = FALSE, results = FALSE}
## dimensions should be 48 x 205 (5 metadata + 200 species columns); all species columns should be numeric.
zoo.abnd.2012 <- read_csv(here::here(save.dir, "abnd_2012_orig_clean.csv"))

## same for biomass; same expected structure as the abundance
zoo.biomass.2012 <- read_csv(here::here(save.dir, "biomass_2012_orig_clean.csv"))
```
  Convert columns to the proper type, arrange the datasets by habitat & station, etc.
```{r clean_zoo_data_2012, results = FALSE}
zoo.abnd.2012 <- zoo.abnd.2012 %>% 
  mutate(station = factor(station, levels = c("Konski1", "Konski2", "Ribka1", "Ribka2", "Gradina1", "Gradina2"))) %>%
  arrange(habitat, station)

zoo.biomass.2012 <- zoo.biomass.2012 %>% 
  mutate(station = factor(station, levels = c("Konski1", "Konski2", "Ribka1", "Ribka2", "Gradina1", "Gradina2"))) %>%
  arrange(habitat, station)
```
  Remove all species not present in the datasets (= all-0 columns). 
```{r clean_zoo_data_2012_2, results = FALSE}
## result should have dimensions 48 x 63 (58 species + 5 metadata columns) 
zoo.abnd.2012 <- zoo.abnd.2012 %>% 
  gather(key = species, value = sp_count, -c(station:replicate)) %>% 
  group_by(species) %>% 
  filter(sp_count > 0) %>%
  spread(species, sp_count, fill = 0) %>%
  arrange(habitat, station)

zoo.biomass.2012 <- zoo.biomass.2012 %>% 
  gather(key = species, value = sp_biomass, -c(station:replicate)) %>% 
  group_by(species) %>% 
  filter(sp_biomass > 0) %>%
  spread(species, sp_biomass, fill = 0) %>%
  arrange(habitat, station)
```
  Transform to long format.  
```{r zoo_data_long_2012}
zoo.abnd.2012.long <- zoo.abnd.2012 %>% 
  gather(key = species, value = sp_count, -c(station:replicate))

zoo.biomass.2012.long <- zoo.biomass.2012 %>% 
  gather(key = species, value = sp_biomass, -c(station:replicate))
```

##### Alpha diversity indices  

```{r alpha_diversity_2012}
## uses custom function for convenience - has to be imported first! 
alpha.div.2012 <- zoo.abnd.2012 %>%
  select(-c(station:replicate)) %>%
  alpha_diversity()

## add the metadata columns (row order is not changed, so possible) 
(alpha.div.2012 <- bind_cols(zoo.abnd.2012 %>% select(station:replicate), alpha.div.2012)
)
```
  Summarize these diversity indices by station & habitat.
```{r summarize_alpha_diversity_2012}
## STILL haven't learned how to use the functions from package sjPlot for printing pretty (and easy!) tables...   
alpha.div.2012 %>% 
  group_by(station, habitat) %>%
  summarise(h_mean = mean(shannon_h), h_sd = sd(shannon_h), 
            j_mean = mean(evenness_j), j_sd = sd(evenness_j),
            h_eff_mean = mean(h_effective), h_eff_sd = sd(h_effective)
            ) %>% 
  arrange(habitat, station)
```
  
  2. Species accumulation curves   
```{r sp_accumulation_curves_2012}
sac.2012 <- specaccum(select(zoo.abnd.2012, -c(station:replicate)))

plot(sac.2012, 
     xlab = "Samples", ylab = "Cumulative species richness", 
     ci.type = "polygon", ci.col = "light blue")
```
  Again, about 10 (maybe a little more) samples seem to be enough to capture most of the biodiversity in the study area (in terms of species richness) - this is where the curve starts to smooth out (slope < 1). In reality, there are 4 samples/station & habitat - clearly not enough. Also supported by the horrifying species richness values (sometimes only 1 species??). I'm putting it down as a result of my learning the taxonomy, methods etc.  
  I'm going to go through the motions of analyzing this dataset in the same way as the previous 2, but I'm not going to trust the results very much.  
  
##### Species pool  
  Estimate the number of **unobserved species** in the study area.  
  First - in the different habitats in Sozopol Bay.  
```{r sp_pool_habitat_2012}
## this function is based on incidences in sample sites - presence/absence data; gives a single estimate for a collection of sample sites
specpool(select(zoo.abnd.2012, -c(station:replicate)), 
         pool = zoo.abnd.2012$habitat, 
         smallsample = TRUE)

## this function is quantitative - based on abundances on single sample site
estimateR(select(zoo.abnd.2012, -c(station:replicate)))
```
  In the sandy sediments in Sozopol Bay, 69 % of the species pool are captured based on the most severe measure (second-order jacknife), and 87.5 % - based on the most forgiving measure (bootstrap).   
  In the seagrasses in Sozopol Bay, 72 % of the species pool are captured based on the most severe measure (second-order jacknife), and 90 % - based on the most forgiving measure (bootstrap).   
  
  In reality, the two habitats were not really distinct - the sand samples were taken too close to the seagrass meadows, in the case of Gradina - in unvegetated patches INSIDE the meadows, so I'm not sure if a distinction is possible from this data.     
  
  Then - at the different stations.   
```{r sp_pool_station_2012}
## this function is based on incidences in sample sites - presence/absence data; gives a single estimate for a collection of sample sites
specpool(select(zoo.abnd.2012, -c(station:replicate)), 
         pool = zoo.abnd.2012$station, 
         smallsample = TRUE)

## this function is quantitative - based on abundances on single sample site
estimateR(select(zoo.abnd.2012, -c(station:replicate)))
```
  
  Let's do one final estimate of the whole Sozopol Bay - all samples pooled.  
```{r sp_pool_all_2012}
## this function is based on incidences in sample sites - presence/absence data; gives a single estimate for a collection of sample sites
specpool(select(zoo.abnd.2012, -c(station:replicate)), 
         smallsample = TRUE)

```
  When all stations/habitats pooled, 83 % of the species pool are estimated to be captured by this dataset based on 2nd order jacknife (the most severe measure), and 90 % - based on Chao & bootstrap - the most tolerant measures.
  
##### Taxonomic distance & diversity  
  Calculate the **taxonomic distance** for the zoobenthic communities in Sozopol Bay in 2012. Again, this cannot be considered relevant / meaningful, since there are samples containing a single species which ought to be excluded altogether from all further analysis...    
```{r tax_distance_2012}
## we'll use the same taxonomic distance for the master species list as before

## calculate the taxonomic distinctness indices for the abundance dataset
(tax.distinctness.2012 <- taxondive(select(zoo.abnd.2012, -c(station:replicate)), tax.dist.sand)
)

## get the summary - includes a significance test on Delta+
summary(tax.distinctness.2012)

```

  Plot the observed values of D-plus in the two habitats, and add the confidence limits.  
```{r plot_dplus_2012}
s.l.dplus.2012 <- bind_cols(S = tax.distinctness.2012$Species,
                            Dplus = tax.distinctness.2012$Dplus,
                            Lambda = tax.distinctness.2012$Lambda,
                            station = zoo.abnd.2012$station, 
                            habitat = zoo.abnd.2012$habitat)

plot.dplus.2012 <- ggplot(s.l.dplus.2012, aes(x = S, y = Dplus, color = station)) +
  scale_color_brewer(palette = "Set2", 
                     labels = c("K1", "K2", "R1", "R2", "G1", "G2")) +
  geom_point(alpha = 0.85, size = 2) +
  xlim(0, 100) + 
  labs(x = "Number of species", y = expression(paste(Delta, "+"))) + 
  facet_wrap(~habitat, labeller = as_labeller(c("S" = "sand", "Z" = "Zostera"))) + 
  text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1.1), strip.x = rel(1.1), title.x = rel(1.1), title.y = rel(1.1), legend.title = rel(1.1))
  
## add confidence/tolerance lines
(plot.dplus.2012 <- plot.dplus.2012 + 
    geom_line(aes(x = sp_number, y = lower), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = upper), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = average), data = dplus.sim.conf.int, color = "grey40", lwd = 0.3)
)

```
  Again, there are too few species in the samples for this to be a meaningful analysis. Many of the samples would have a disturbed community structure if the results could be trusted - esp. G1-2 in seagrass, and also somewhat in sand. Overall, K1-2 which have the highest species richness in both sand and in seagrass are the closest to the average expected Delta+.  
  
  Now plot the observed Lambda values, with the theoretical (simulated) confidence intervals.  
```{r plot_lambda_2012}
plot.lambda.2012 <- ggplot(s.l.dplus.2012, aes(x = S, y = Lambda, color = station)) +
  scale_color_brewer(palette = "Set2",
                      labels = c("K1", "K2", "R1", "R2", "G1", "G2")) +
  geom_point(alpha = 0.85, size = 2) +
  xlim(0, 100) + 
  labs(x = "Number of species", y = expression(paste(Lambda, "+"))) +
  facet_wrap(~habitat, labeller = as_labeller(c("S" = "sand", "Z" = "Zostera"))) + 
  text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1.1), strip.x = rel(1.1), title.x = rel(1.1), title.y = rel(1.1), legend.title = rel(1.1))

## add the confidence/tolerance intervals
(plot.lambda.2012 <- plot.lambda.2012 + 
    geom_line(aes(x = sp_number, y = lower), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = upper), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3) + 
    geom_line(aes(x = sp_number, y = average), data = lambda.sim.conf.int, color = "grey40", lwd = 0.3)
)

```
  Same story here: very high variability between samples, mostly very low values of Lambda - because the few species that are present are of similar taxonomic groups. K1-2 are again the closest to the expected average values.  
```{r plot_composite_dplus_lambda_2012}
## combine the 2 previous plots on one graph. They share a legend, so we'll jump through some (neccessary) hoops to put it at the bottom 

## plot them together in a grid
plot.dplus.l.combined.2012 <- cowplot::plot_grid(plot.dplus.2012 + theme(legend.position = "none"), 
                                                 plot.lambda.2012 + theme(legend.position = "none"), 
                                                 labels = c("A", "B"), ncol = 1, align = "v")

## get the legend from one of the plots, and put it at the bottom
dplus.legend <- cowplot::get_legend(plot.dplus.2012 + theme(legend.position = "right"))

(plot.dplus.l.combined.2012 <- cowplot::plot_grid(plot.dplus.l.combined.2012,
                                                  dplus.legend, 
                                                  ncol = 2, rel_widths = c(1, 0.25))
)

## save & clean up
cowplot::save_plot(here::here(figures.dir, "dplus_lambda_combined_2012.png"), 
                   plot.dplus.l.combined.2012, 
                   base_aspect_ratio = 0.9, base_width = 5.5, dpi = 300)

rm(dplus.legend)
```
  
  Same conclusions as above. Probably won't include these in the thesis results, and won't pool them with the other seagrass samples (which were collected in the same way) - this only showcases the need for proper training before embarking on experiments. Any and all conclusions based on this data can only be tentative and partial, and more than a little doubtful.  
  
##### Graphical analyses  
###### **ABC curves**  
  First, we'll calculate them on each replicate separately:
```{r abc_2012}
(abc.2012 <- abc(zoo.abnd.2012.long, zoo.biomass.2012.long, 
                 abnd.val = sp_count, biomass.val = sp_biomass, 
                 station, habitat, replicate)
)
## result is a list: 1) grouped df containing the curves (long), 2) summarized df with the W statistic per replicate - the distance between the 2 curves  

```
  
  We'll plot W, because there are too many stations & replicates and the curves will be unreadable.   
```{r plot_w_2012}
ggplot(abc.2012[[2]], aes(x = station, y = w, colour = factor(habitat))) + 
  geom_boxplot() + 
  scale_x_discrete(name = "Station", 
                   labels = c("K1", "K2", "R1", "R2", "G1", "G2")) + 
  ylab("W") + 
  theme(legend.title = element_blank()) +
  geom_hline(yintercept = 0)
```

  W > 0 for most samples, but the variability is incredibly high, esp. in sand & for R1 and G2 - hardly surprising; those samples contain the lowest number of species. Just as biased as the previous analysis.  
  
  Plot the summary ABC curves - per station and habitat. 2 rows (for the 2 years) + 6 columns (stations) in the plot.  
```{r summarize_abnd_biomass_2012}
## summarize the abundance and biomass data per year (average)  
(summary.abnd.2012 <- zoo.abnd.2012.long %>%
   group_by(station, habitat, species) %>%
   summarize(mean_count = mean(sp_count))
)

(summary.biomass.2012 <- zoo.biomass.2012.long %>%
   group_by(station, habitat, species) %>%
   summarize(mean_biomass = mean(sp_biomass))
)
```
  Now calculate the summary ABC for the seagrass and the sand communities for the 2012 stations.  
```{r summary_abc_2012}
(abc.summary.2012 <- abc(summary.abnd.2012, summary.biomass.2012, 
                         abnd.val = mean_count, biomass.val = mean_biomass, 
                         station, habitat)
)
```
  Plot them!   
```{r plot_summary_abc_2012}
## reshape the data for easier plotting - and to have a legend..
abc.summary.2012.long <- abc.summary.2012[[1]] %>% 
  gather(key = variable, value = value, -c(station:sp_rank)) %>%
  mutate(variable = case_when(variable == "cum_abnd" ~ "abundance", 
                              variable == "cum_biomass" ~ "biomass"))

## make named character vectors for the custom station & habitat labels   
stations.2012 <- c("K1", "K2", "R1", "R2", "G1", "G2")
names(stations.2012) <- as.character(unique(abc.summary.2012[[1]]$station))

habitats.2012 <- c("sand", "Zostera")
names(habitats.2012) <- unique(abc.summary.2012[[1]]$habitat)

## plot 
plot.summary.abc.2012 <- ggplot(abc.summary.2012.long, 
                                aes(x = sp_rank, y = value, colour = variable)) + 
  geom_line() + 
  # apply axis transformations 
  scale_x_log10() +
  coord_trans(y = "modif_logistic")  + 
  # curve colours and legend 
  scale_colour_manual(values = c("skyblue", "orange"), name = "") + 
  theme(legend.position = "top") + 
  # facets & labels
  facet_grid(habitat ~ station, 
             labeller = labeller(station = as_labeller(stations.2012),
                                 habitat = as_labeller(habitats.2012))) + 
  labs(x = "Species rank (log)", y = "Cumulative %")

## modify text size a little 
(plot.summary.abc.2012 <- plot.summary.abc.2012 + text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1), title.x = rel(1.1), title.y = rel(1.1), strip.x = rel(1.1), strip.y = rel(1.1))
)

## and save this - huge, because I think it will be displayed best as a whole-page graph.. 
ggsave(here::here(figures.dir, "summary_abc_2012.png"), 
       plot.summary.abc.2012, 
       width = 25, height = 15, units = "cm", dpi = 300)

rm(abc.summary.2012.long)
```
  Spectacularly bad.. For what it's worth - all the seagrass samples have curves situated close together and sometimes crossing - indicative of slight disturbance, or would be if the underlying data were any good. The sand samples show more or less the same pattern - slight disturbance.

###### **Partial dominance curves**  

```{r partial_dominance_2012}
## will be calculated directly on the summarized abundance/biomass data
(pd.summary.2012 <- partial_dominance_curves(summary.abnd.2012, summary.biomass.2012, 
                                                abnd.val = mean_count, biomass.val = mean_biomass, 
                                                station, habitat)
)
```

```{r plot_partial_dominance_2012}
## reshape the data as before..
pd.summary.2012.long <- pd.summary.2012 %>% 
  gather(key = variable, value = value, -c(station:sp_rank)) %>%
  mutate(variable = case_when(variable == "partial_abnd" ~ "abundance", 
                              variable == "partial_biomass" ~ "biomass"))

## plot
plot.pd.2012 <- ggplot(pd.summary.2012.long, aes(x = sp_rank, y = value, colour = variable)) + 
  geom_line() + 
  # apply axis transformations 
  scale_x_log10() +
  # curve colours and legend 
  scale_colour_manual(values = c("skyblue", "orange"), name = "") + 
  theme(legend.position = "top") + 
  # facets & labels
  facet_grid(habitat ~ station, 
             labeller = labeller(station = as_labeller(stations.2012), 
                                 habitat = as_labeller(habitats.2012))) + 
  labs(x = "Species rank (log)", y = "%")

## modify text size a little
(plot.pd.2012 <- plot.pd.2012 + text_size(text.x = rel(1.2), text.y = rel(1.2), legend.text = rel(1), title.x = rel(1.1), title.y = rel(1.1), strip.x = rel(1.1), strip.y = rel(1.1))
)

## save, just in case, although I don't much see the point in using ALL of them, when they're showing basically the same thing..
ggsave(here::here(figures.dir, "summary_pd_2012.png"), 
       plot.pd.2012, 
       width = 25, height = 15, units = "cm", dpi = 300)

rm(pd.summary.2012.long)
```
  Very ragged curves, because very few species per sample. The successive removal of the dominants from the calculation makes the incredibly low number of species really obvious, esp. in the sand samples from Ribka and Gradina (the curves are shortish and jump all over the place). Only the samples from Konski somehat resemble the expected shape of partial dominance curves.  
  
  **All things considered, for the 2012 samples, again it might be best to summarise at the site level (see mvabund model output in the Community composition notebook). That way, the variability & really, really low species richness might be compensated a little.**  
  

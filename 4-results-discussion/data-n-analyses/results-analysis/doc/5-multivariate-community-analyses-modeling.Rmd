---
title: "Multivariate analyses of community structure (modeling)"
date: "2019-03-25"
output: html_notebook
---

This notebook contains all multivariate analyses of zoobenthic community structure using the new, nearly unheard-of modeling methods: packages mvabund, boral.  
Again, to make it self-contained, there will be the same repetitive setup/data import/preparation part.  

***  

Setup!
```{r setup, include = FALSE}
library(knitr)

knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(2, 2, .1, 2))  # smaller margin on top
})

## set the working directory to one up (all notebooks - kept in their own subdirectory within the project directory).
opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

## set knitr options for knitting code into the report.
opts_chunk$set(cache = TRUE, # save results so that code blocks aren't re-run unless code changes
               autodep = TRUE, # ..or unless a relevant earlier code block changed
               cache.comments = FALSE, # don't re-run if the only thing that changed was the comments
               highlight = TRUE, 
               small.mar = TRUE)
```

Define the working subdirectories.  
```{r workspace_setup}
## print the working directory, just to be on the safe side
paste("You are here: ", getwd())

data.dir <- "data"    ## input data files
functions.dir <- "R"  ## functions & scripts
save.dir <- "output"  ## clean data, output from models & more complex calculations
figures.dir <- "figs" ## plots & figures 
```

Import libraries.  
```{r import_packages, results = FALSE}
library(here) ## painless relative paths to subdurectories, etc.
library(tidyverse) ## data manipulation, cleaning, aggregation
library(viridis) ## smart & pretty colour schemes
library(mvabund) ## multivariate modeling analyses in ecology
library(boral) ## more multivariate modeling analyses in ecology
```

Organize some commonly-used ggplot2 modifications into a more convenient (and less repetitive) format. One day, I MUST figure out the proper way to set the theme..    
```{r custom_ggplot_settings_helpers}
## ggplot settings & things that I keep reusing
# ggplot_theme <- list(
#   theme_bw(),
#   theme(element_text(family = "Times"))
# )

## always use black-and-white theme
theme_set(theme_bw())

## helper to adjust ggplot text size & avoid repetitions 
text_size <- function(text.x = NULL,
                      text.y = NULL,
                      title.x = NULL,
                      title.y = NULL,
                      legend.text = NULL,
                      legend.title = NULL, 
                      strip.x = NULL, 
                      strip.y = NULL) {
  theme(axis.text.x = element_text(size = text.x),
        axis.text.y = element_text(size = text.y),
        axis.title.x = element_text(size = title.x),
        axis.title.y = element_text(size = title.y),
        legend.text = element_text(size = legend.text), 
        legend.title = element_text(size = legend.title), 
        strip.text.x = element_text(size = strip.x), 
        strip.text.y = element_text(size = strip.y)
        )
}


## log y/min + 1 transform - useful for species counts/biomass data visualization
log_y_min <- function(y) {
  log(y / min(y[y > 0]) + 1)
}

```

***  

#### **Sand stations (Burgas Bay, 2013-2014)**  
Import zoobenthic abundance data (cleaned and prepared).  
```{r import_zoo_abnd_sand}
zoo.abnd.sand <- read_csv(here(save.dir, "abnd_sand_orig_clean.csv"))

## convert station to factor (better safe than sorry later, when the stations are not plotted in the order I want them)
(zoo.abnd.sand <- zoo.abnd.sand %>% 
    mutate(station = factor(station, levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva")))
)
```

Remove the all-0 species (= not present in the current dataset).  
Maybe also remove the singletons (species appearing only once in the whole dataset and represented by a single individual = so rare that it's unlikely they carry important information, but it would probably improve the run times).  
```{r filter_zoo_data_sand}
(zoo.abnd.flt.sand <- zoo.abnd.sand %>%
   select(-c(station:replicate)) %>%
   select(which(colSums(.) > 0))
)
```


##### **LVM - model-based ordination**
Perform a model-based unconstrained ordination by fiting a pure latent variable model (package boral - Hui et al., 2014). This will allow to visualize the multivariate stations x species data - similar to nMDS, can be interpreted in the same way.   
I'm including a (fixed) row effect to account for differences in site total abundance - this way, the ordination is in terms of **species composition**.   
NB this takes about a million years to run! 
```{r lvm_sand}
lvm.sand <- boral(y = zoo.abnd.flt.sand, 
                  family = "negative.binomial",
                  
                  ## we want to control for site effects - there are 6 sites with 9 replicates each
                  row.eff = "fixed", row.ids = matrix(rep(1:6, each = 9), ncol = 1),  
                  ## 2 latent variables = 2 axes on which to represent the zoobenthic data
                  lv.control = list(num.lv = 2) 
                  
     #              ## example control structure, to check if function does what I want, because otherwise it takes an intolerably long time, and I'll shoot myself if I have to wait for it again
     #              mcmc.control = list(n.burnin = 10, n.iteration = 100,
     # n.thin = 1)
     #              
     
                  )

```

Check the summary and diagnostic plots for the LVM.  
```{r summary_lvm_sand}
summary(lvm.sand)

## model fit diagnostic plots
plot(lvm.sand) 
```
The residuals plots look fine (no patterns in the residuals vs fitted, so variance is homogeneous, the quantile plot shows a normal distribution of the residuals) - the model fits the data pretty well.  

Save the sand LVM.  
```{r save_lvm_sand}
write_rds(lvm.sand, 
          here(save.dir, "lvm_sand.RDS"))
```

Examine the biplot obtained by fitting the LVM, as well as the 20 most "important" species.   
```{r check_biplot_lvm_sand}
lvsplot(lvm.sand, jitter = T, biplot = TRUE, ind.spp = 20)
```

All in all, the final result resembles the nMDS ordination very much - same 4 clusters (Kraimorie + Chukalya, AKin, Agalina, Sozopol + Paraskeva). Kraimorie and Chukalya are better distinguished on the LVM plot than on the MDS, but still.  
The run time is extremely, extremely long (~1h), but the data don't need to be transformed, and the model fit can be examined and adjusted if necessary.    
The species singled out as significant are probably somewhat different - have to check!   

Redo the biplot, because this one is not very pretty. I'm not adding the species on top, first because I'm too lazy to figure out the procedure for ordering them, and second because the plot gets too busy.   
```{r extract_lvm_coord_sand}
## extract the LV coordinates of the stations from the model, so that the plot can be redone in ggplot 
lvs.coord.sand <- as_tibble(lvm.sand$lv.median)

## add the stations from the original zoobenthic table (order was not modified)
(lvs.coord.sand <- lvs.coord.sand %>% 
  bind_cols(zoo.abnd.sand %>% select(station))
)

```

Make the plot and save it.  
```{r plot_lvm_sand}
(plot.lvm.sand <- ggplot(lvs.coord.sand) + 
    geom_point(aes(x = lv1, y = lv2, colour = station)) + 
    scale_color_brewer(palette = "Set2", name = "station", 
                       labels = paste0("S", as.numeric((unique(lvs.coord.sand %>% pull(station)))))) +
   labs(x = "LV1", y = "LV2")
)

ggsave(file = here(figures.dir, "lvm_sand.png"), 
       plot.lvm.sand, 
       width = 15, units = "cm", dpi = 300)
```

##### **GLM fitting for abundance - environmental data**  
Let's fit GLMs to the sites x species matrix to try and explain the observed differences in community structure by the variation of the environmental parameters.  
These functions all come from package **mvabund**.  
Import the environmental data - the one cleaned, prepared and saved in the previous notebook (classical multivariate methods). It contains long-term averages for the water column data (2009-2011 + 2013-2014) at each station, repeated for each replicate, and the sediment data (2013-2014), again repeated to the same number of replicates. Only the variables determined to be significant by PCA are kept.       
```{r import_env_data_sand} 
env.sand <- read_csv(here(save.dir, "env_data_ordinations_sand.csv"))

## convert station to factor
(env.sand <- env.sand %>% 
    mutate(station = factor(station,
                            levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva")))
)
```
Station is a factor, the rest of the variables are numeric.  

Turn the zoobenthic data (minus the all-0 taxa) into a matrix - easier for the mvabund package and methods to deal with.  
```{r matrix_abnd_sand}
## there is already one subset of filtered count data (54 x 147) - use it 
zoo.mvabnd.sand <- mvabund(zoo.abnd.flt.sand)
```

###### **manyGLM by LVM clusters**
First, let's see if the groups from the latent variable model (more or less equal to the clusters from the classical ordination) are valid, and which species exhibit a response.  
```{r clusters_lvm_sand}
## construct the vector of the clusters by hand, it's easier that way.. 
lvm.clusters.sand <- c(rep(1, times = 18), rep(2:4, each = 9), rep(3, times = 9))

## convert to factor
(lvm.clusters.sand <- factor(lvm.clusters.sand))
```

Check the model assumptions. 
1. Mean-variance assumption => determines the choice of family parameter. Can be checked by plotting residuals vs fits: if little pattern - the chosen mean-variance assumption is plausible.  
Another way: direct plotting (variance ~ mean), for each species within each factor
level.  
```{r check_mean_variance_lvm_sand}
plot(manyglm(zoo.mvabnd.sand ~ lvm.clusters.sand, family = "negative.binomial"))

meanvar.plot(zoo.mvabnd.sand ~ lvm.clusters.sand, table = TRUE)
```

It's not perfect, but it's not too terrible either. 

2. Assumed relationship between mean abundance and environmental variables - link function and formula.
When quantitative variables are included in the model (for now, not relevant - will be in the next model) -> if there is a trend in size of residuals at different fitted values (e.g. U-shape,..) = violation of the log-linearity assumption.
  
Everything looks more or less fine; fit the model. 
```{r fit_glms_lvm_sand}
glms.lvm.sand <- manyglm(zoo.mvabnd.sand ~ lvm.clusters.sand, 
                         family = "negative.binomial")

```

Explore the fit (residuals, diagnostic plots, etc.).  
```{r explore_glms_lvm_sand}
## residuals vs fitted values
plot(glms.lvm.sand)


## all traditional (g)lm diagnostic plots
plot.manyglm(glms.lvm.sand, which = 1:3)


### source mvabund GLM plotting functions modified to use a grey palette - I just can't redo these plots on my own, the function is doing too complicated things internally to scale the x and y axes
source(here(functions.dir, "default.plot.manyglm_grey.R"))
source(here(functions.dir, "plot.manyglm_grey.R"))

par(mfrow = c(2,2))
lapply(1:3, function(i) plot.manyglm.grey(glms.lvm.sand, which = i, sub.caption = ""))
par(mfrow = c(1, 1))

```

I really don't like the rainbow palette, but I would like to include these plots in my thesis results.. Will have to do something about it, just not right now.  
Save the model!  
```{r save_glms_lvm_sand}
write_rds(glms.lvm.sand, 
          here(save.dir, "glms_lvm_sand.RDS"))
```

Let's see the model summary (NB takes a LOT of time if there are many resamplings!).  
```{r summary_glms_lvm_sand}
(glms.lvm.sand.summary <- summary(glms.lvm.sand, 
                                  test = "LR", p.uni = "adjusted",
                                  nBoot = 999, ## limit the number of permutations if you just want to check it out
                                  show.time = "all")
)
```

The factor (here - groups outlined by the LVM) is highly significant according to the models.  
This also allows us to see which species exhibit a response to the chosen factor. 
The LR (likelihood ratio) statistic is used as a measure of the strength of individual taxon contributions to the observed patterns. 
I'll save the summary for safekeeping, but I'll also run an anova - to get an analysis of deviance table on the model fit (also better for extracting the species contributions, or at least I know how to do it).  
```{r save_summary_glms_lvm_sand}
write_rds(glms.lvm.sand.summary, 
          here(save.dir, "glms_lvm_sand_summary.RDS"))
```

Run the anova on the model. 
```{r anova_glms_lvm_sand}
(glms.lvm.sand.aov <- anova.manyglm(glms.lvm.sand, 
                                    test = "LR", p.uni = "adjusted", 
                                    nBoot = 999, ## limit the number of permutations for a shorter run time   
                                    show.time = "all") 
)
```
I probably shouldn't have printed all this out, but oh well who cares.  

Save the ANOVA, too.  
```{r save_anova_glms_lvm_sand}
write_rds(glms.lvm.sand.aov, 
          here(save.dir, "glms_lvm_sand_anova.RDS"))
```

NOW let's get the taxa with the highest contributions to the tested pattern (here - clusters in the LVM, which are really the different soft-bottom habitats).  
```{r relative_taxon_contrib_glms_lvm_sand}
top_n_sp_glm <- function(glms.aov, tot.dev.expl = 0.75) {
  ## helper retrieving the top n species with the highest contribution to the patterns tested by the GLMs, in decreasing order.
  ## Arguments: glms.aov - results from an ANOVA on the fitted GLMs
  ##            dev.explained - proportion of explained deviance to use as cutoff
  
  ## get the change in deviance due to the tested pattern (= 2nd row from table of univariate test stats), and sort the species in order of decreasing contribution
  uni.sorted <- sort(glms.aov$uni.test[2, ], decreasing = TRUE, index.return = FALSE)

  ## start at 10 species and check how much of the deviance is explained by their contributions. Repeat, increasing by increments of 10 until the desired explained deviance (set at function call) is reached. 
  top.n.sp <- 10
  dev.expl <- sum(uni.sorted[1:top.n.sp])/sum(uni.sorted)
  
  while(dev.expl < tot.dev.expl) {
    top.n.sp <- top.n.sp + 10
    dev.expl <- sum(uni.sorted[1:top.n.sp])/sum(uni.sorted)
  }
  
  ## print the total deviance explained - just for information
  print(paste("Total deviance explained:", round(dev.expl, 3)))
  
  ## return the final top species (and their univariate contributions, just in case) 
  top.sp <- uni.sorted[1:top.n.sp]
  return(top.sp)
}

## get the top contributing species for the initial sand GLMs 
(top.sp.glms.lvm.sand <- top_n_sp_glm(glms.lvm.sand.aov, tot.dev.expl = 0.75)
)

## unfortunately, mvabund likes to rename my species when converting the data to matrix (no spaces in names), and since I'm going to look them up in my initial untransformed count data, I have to change them back..   
names(top.sp.glms.lvm.sand) <- names(top.sp.glms.lvm.sand) %>% 
  str_replace(pattern = "\\.", replacement = " ")

top.sp.glms.lvm.sand
```

Try to plot these top contributing species - for whatever that's worth, because 50 species on a plot is a monstrosity.  

```{r plot_relative_taxon_contrib_glms_lvm_sand}
## get the species and their abundances from the original count data, and transform them to long format
(abnd.top.sp.glms.lvm.sand <- zoo.abnd.sand %>% 
   select(station, names(top.sp.glms.lvm.sand)) %>% 
   gather(key = "species", value = "count", -station) %>% 
   ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
   mutate(species = factor(species, levels = rev(names(top.sp.glms.lvm.sand))))
)

plot_top_n <- function(top.n.sp.data, mapping, labs.legend, lab.y, palette) {
  ## helper for plotting top n species. Was hoping to avoid repeating it from way back when, but no dice. 
  ## Arguments: top.n.sp.data - data frame (long) of top species' counts/biomasses at the different stations
  ##            mapping - mappings of the aesthetics
  ##            labs.legend - labels the use for the legend entries
  ##            lab.y - custom label for y axis
  ##            palette - custom colour palette (for consistency with other plots)
  
  ggplot(top.n.sp.data, mapping) +
    geom_point(alpha = 0.75) + # make points larger & partially transparent
    scale_color_brewer(palette = palette,  labels = labs.legend) + 
    ylab(lab.y) + 
    coord_flip() 
}


(plot.top.sp.glms.lvm.sand <- plot_top_n(abnd.top.sp.glms.lvm.sand,
                                         mapping = aes(x = species, y = log_y_min(count), colour = station),
                                         labs.legend = paste0("S", as.numeric(unique(abnd.top.sp.glms.lvm.sand$station))),
                                         lab.y = "Abundance (log(y/min + 1))",
                                         palette = "Set2"
                                        ) +
    theme(legend.position = "top")

)
```

Well this is a nightmarish plot.. I'll probably just put this awfulness in a table and call it a day, or play with lvsplot and the modeled ordination plot, if a plot is what's needed.  

Extract the top-contributing species to each cluster (this same nightmare above, but as a table). This chunk is hopelessly ugly and clumsy (and I'll have to repeat it for the seagrass, too!), but I'm tired of being stuck on this. I still have many, MANY more things to do, and more time-consuming ones too..  
```{r table_relative_taxon_contrib_glms_lvm_sand}
top_sp_glms_table <- function(manyglms.obj.smry, group, p = 0.05) {
  ### extracts the top species in a group for which there is an observed effect in a manyglm test, at the specified probability level.
  ### Returns: tibble with the top species for the specified group/cluster, sorted (descending) by univariate LR value of the species, significant at the given p level. 
  
  ## extract the univariate LR coefficients of the species and their p-values 
  sp_univar <- as_tibble(manyglms.obj.smry$uni.test, rownames = "species")
  sp_p <- as_tibble(manyglms.obj.smry$uni.p, rownames = "species")

  ## combine in the same tibble
  sp_all <- left_join(sp_univar, sp_p, by = "species")  
  
  ## rename the columns
  sp_all <- sp_all %>% 
    rename_at(vars(contains(".x")), list(~str_replace_all(., pattern = ".x", ".LR"))) %>% 
    rename_at(vars(contains(".y")), list(~str_replace_all(., pattern = ".y", ".p")))
  
  ## filter only the group/cluster we want, at the p-level we want
  sp_all_flt <- sp_all %>% 
    select(species, contains(group)) %>% 
    filter_at(vars(contains(".p")), all_vars(. < p)) %>%
    arrange_at(vars(contains(".LR")), list(~desc(.)))

}

top.sp.abnd.glms.lvm.sand <- lapply(names(glms.lvm.sand.summary$aliased), function(x) top_sp_glms_table(glms.lvm.sand.summary, x, p = 0.05)) 

## fix species names (remove dot) 
top.sp.abnd.glms.lvm.sand <- lapply(top.sp.abnd.glms.lvm.sand, function(x) x %>% mutate(species = str_replace(species, pattern = "\\.", replacement = " ")))

## rename columns (= group names) - right now they are something like "lvm.clusters.sand2" etc.
top.sp.abnd.glms.lvm.sand <- lapply(top.sp.abnd.glms.lvm.sand, function(x) x %>% rename_at(vars(contains("lvm.clusters.sand")), list(~str_replace_all(., pattern = "lvm.clusters.sand", "group_"))))

top.sp.abnd.glms.lvm.sand <- lapply(top.sp.abnd.glms.lvm.sand, function(x) x %>% rename_at(vars(contains("Intercept")), list(~str_replace_all(., pattern = "\\(Intercept\\)", "group_1"))))


## pull the abundances from the original count df and add to the summary glm tables 
## make a long df of abundances & add clusters  
zoo.abnd.sand.long <- zoo.abnd.sand %>%
  select(-c(month:replicate)) %>%
  gather(key = "species", value = "count", -station) %>% 
  mutate(group = case_when(station %in% c("Kraimorie", "Chukalya") ~ 1, 
                           station == "Akin" ~ 2, 
                           station %in% c("Sozopol", "Paraskeva") ~ 3, 
                           station == "Agalina" ~ 4))

## sum sp abundances by group; nest by group
zoo.abnd.sand.long.smry <- zoo.abnd.sand.long %>% 
  group_by(species, group) %>% 
  summarise(total_count = sum(count)) %>% 
  group_by(group) %>%
  nest()

## add the counts to the group dfs - wow that's an ugly, ugly hack. Wish I had more time to write this up properly.. 
top.sp.abnd.glms.lvm.sand <- map2(top.sp.abnd.glms.lvm.sand, zoo.abnd.sand.long.smry %>% pull(group), ~left_join(.x, zoo.abnd.sand.long.smry %>% filter(group == .y) %>% unnest(), by = "species"))

## since these are sum counts over all the replicates (that's why the monstrous numbers), average them to be mean counts per group. NB different groups consist of different numbers of replicates, b.c. some groups consist of more than one station
(top.sp.abnd.glms.lvm.sand <- map2(top.sp.abnd.glms.lvm.sand, c(18, 9, 18, 9), function(x, y) x %>% mutate(mean_count = total_count/y))
)
```

To determine the relative taxon contribution to patterns: LR statistic - a measure of strength of individual taxon contributions. LR expresses how many times more likely the data are under one model than the other. This likelihood ratio, or equivalently its logarithm, can then be used to compute a p-value, or, compared to a critical value, to decide whether to reject the null model in favour of the alternative model.  

In this case, the model shows which species exhibit a reaction based on the chosen groups - in other words, which species are more likely to be more/less abundant in each group.  
For **group 1** (= S1-S2), the species/taxa with significantly **higher abundance** are: Oligochaeta, H. filiformis, P. kefersteini, M. palmata, P. cirrifera, A. diadema (among others); and the ones with significantly **lower abundance** - even 0, in some cases - S. bidentata, B.lanceolatum, M. papillicornis, Melita palmata, P. jubatus, and so on.  
For **group 2** (= S3), the species with **higher abundance** are: B. lanceolatum, O. limacina, Oligochaeta (this is this strange artifact of 2013), P. kefersteini, L. flavocapitatus. The species with **lower abundance** are: H. filiformis, A. kagoshimensis, M. stammeri, Melinna palmata, etc.
For **group 3** (= S4-S6), the species with **higher abundance** are: C. gallina, L. mediterraneum - with very high dominance over practically all others; also Pseudocuma longicorne, Spio filicornis. The species with **lower abundance** are: H. filiformis, Oligochaetes (to a certain extent - they are still present, though), A. kagoshimensis, L. koreni, Harmothoe reticulata, Iphinoe tenella, Leiochone leiopygos.  
For **group 4** (= S5), the species with **higher abundance** are: Microdeutopus versiculatus, Eurydice dollfusi, Melita palmata, Polygordius neapolitanus, Polycirrus caliendrum, Polycirrus jubatus, Streptosyllis bidentata. The species with **lower abundance** are: A. kagoshimensis, Melinna palmata, P. cirrifera, P. ciliata, A. alba, I. tenella.   
I love how the species with the highest variances (e.g. C. gallina, the most conspicuous example) are consistently pushed back - have lower LR scores. This is very good - C. gallina in particular is dominant in group 3, but is present also in all other groups - its substrate/depth preferences are very wide, so this is not uncommon. It's not automatically pushed to the top of the list, but its reaction is detected by the manyGLM test. Neat! 
Contrast to the SIMPER results, where the species with the highest variance are consistently at the top - they contribute the most to the similarity, as per the test definition.  

I'm going to save these as separate files (manually), then format them as tables - I know it's a shame, but I'm too frustrated to figure out how to do it programmatically.  
I'll also put them in a word table in my final text, because I don't want to deal with a million separate ones (embedded excel tables don't split over multiple pages).  

**NB In my text, I'm switching the names/places of group 3 and 4, to be consistent with the SIMPER groups (I'm NOT going to repeat all this just to have the numbers match up). So the file names, table names, etc. remain as above. But in the text, I'll have the following: group 1 = S1-S2, group 2 = S3, group 3 = S5, group 4 = S4-S6. REMEMBER THIS SO THERE IS NO CONFUSION!**


###### **manyGLM by environmental parameters**  
Now, let's try to see a different thing - which environmental parameters best describe the species response.  
I'm going to use the PCA-filtered environmental data - it's still going to be a slog, with 7 potential predictors..  
First, construct the formula for the model - will do it separately in case I need to update it later, etc.  
```{r formula_env_manyglm_sand}
(formula.env.glms.sand <- formula(paste("zoo.mvabnd.sand ~", 
                                        paste(env.sand %>% select(-station) %>% names(), collapse = "+")))
)
```

Fit the GLMs to the sand abundance data. 
```{r fit_glms_env_sand}
env.glms.sand <- manyglm(formula.env.glms.sand,
                         data = env.sand,
                         family = "negative.binomial")

```

Explore the fit (residuals, diagnostic plots, etc.).  
```{r explore_glms_env_sand}
## residuals vs fitted values
plot(env.glms.sand)


## all traditional (g)lm diagnostic plots
plot.manyglm(env.glms.sand, which = 1:3)


# ### source mvabund GLM plotting functions modified to use a grey palette - I just can't redo these plots on my own, the function is doing too complicated things internally to scale the x and y axes
# source(here(functions.dir, "default.plot.manyglm_grey.R"))
# source(here(functions.dir, "plot.manyglm_grey.R"))
# 
# par(mfrow = c(2,2))
# lapply(1:3, function(i) plot.manyglm.grey(glms.lvm.sand, which = i, sub.caption = ""))
# par(mfrow = c(1, 1))

```

Well, it's good enough if you ask me (still the kinda strange "line" at lin.pred = -6; otherwise residuals are random enough).  

Save the model!  
```{r save_glms_env_sand}
write_rds(env.glms.sand, 
          here(save.dir, "glms_env_sand.RDS"))
```

Run the anova on the model - I want to see which predictors best explain the species abundance patterns I have. This is one function that would greatly benefit from being run in parallel.. 
```{r anova_glms_env_sand}
(env.glms.sand.aov <- anova.manyglm(env.glms.sand, 
                                    test = "LR", p.uni = "adjusted", 
                                    nBoot = 999, ## limit the number of permutations for a shorter run time   
                                    show.time = "all") 
)
```

The results suggest that the **long-term average water column parameters** have a major influence on the observed community structure; also the **sediment TOM**, and (marginally) the **sediment composition** (gravel content).  
Save the ANOVA - I really, really don't want to have to repeat it.  
```{r save_anova_glms_env_sand}
write_rds(env.glms.sand.aov, 
          here(save.dir, "glms_env_sand_anova.RDS"))
```

Get the taxa with the highest contributions to the tested pattern (here - species most affected by changes in water/environmental quality parameters).  
```{r relative_taxon_contrib_glms_env_sand}
## get the top contributing species for the environmental parameter sand GLMs 
(top.sp.glms.env.sand <- top_n_sp_glm(env.glms.sand.aov, tot.dev.expl = 0.75)
)

## unfortunately, mvabund likes to rename my species when converting the data to matrix (no spaces in names), and since I'm going to look them up in my initial untransformed count data, I have to change them back..   DON'T BE IN A HURRY TO DO THAT IF YOU WANT TO SUBSET THE ORIGINAL MATRIX BEFORE RUNNING TRAITGLM 
names(top.sp.glms.env.sand) <- names(top.sp.glms.env.sand) %>% 
  str_replace(pattern = "\\.", replacement = " ")

```

I'm going to plot these top contributing species, but I'm not using the plot. At least this time it's more manageable, but still not presentable enough.. 

```{r plot_relative_taxon_contrib_glms_env_sand}
## get the species and their abundances from the original count data, and transform them to long format
(abnd.top.sp.glms.env.sand <- zoo.abnd.sand %>% 
   select(station, names(top.sp.glms.env.sand)) %>% 
   gather(key = "species", value = "count", -station) %>% 
   ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
   mutate(species = factor(species, levels = rev(names(top.sp.glms.env.sand)))) %>% 
   ## add clusters from LVM as a column
   mutate(group = case_when(station %in% c("Kraimorie", "Chukalya") ~ 1, 
                            station == "Akin" ~ 2, 
                            station %in% c("Sozopol", "Paraskeva") ~ 3, 
                            station == "Agalina" ~ 4))
)


(plot.top.sp.glms.env.sand <- plot_top_n(abnd.top.sp.glms.env.sand,
                                         mapping = aes(x = species, y = log_y_min(count), colour = factor(group)),
                                         group = abnd.top.sp.glms.env.sand %>% pull(group), 
                                         labs.legend = unique(abnd.top.sp.glms.env.sand$group),
                                         lab.y = "Abundance (log(y/min + 1))",
                                         palette = "Set2"
                                        ) + 
    theme(legend.position = "top")

)
```


Maybe a bit later I'll try to get this nightmare above as a table... 


Final analysis to try: which species respond differently to different environmental parameters?
(= traits analysis - fit single predictive model for all species at all sites, but w/o attempting to explain the different responses using traits - the species ID is used in place of a traits matrix).  
NB only use the top species that exhibited a reaction in the environmental model fit (= the ones accounting for ~75% of the total variability), and only the significant predictors - to improve run times.   
```{r sp_response_glms_env_sand}
sp.response.glms.env.sand <- traitglm(L = zoo.mvabnd.sand[, names(top.sp.glms.env.sand)], 
                                      R = as.matrix(env.sand %>% select(NH4, NO3, PO4, seston, secchi, TOM, gravel)), 
                                      method = "manyglm")


sp.response.glms.env.sand$fourth.corner


# plot this 
a <- max(abs(sp.response.glms.env.sand$fourth.corner))
colort <- colorRampPalette(c("blue","white","red")) 
plot.spp <- lattice::levelplot(t(as.matrix(sp.response.glms.env.sand$fourth.corner)), xlab = "Environmental Variables",
                     ylab = "Species", col.regions = colort(100), at = seq(-a, a, length = 100),
                     scales = list(x = list(rot = 45)))
print(plot.spp)


```

When using LASSO (method = "glm1path"), the algorithm fails to converge - I'm not sure how to interpret it.. Maybe because the function tests each individual species:env.parameter interaction (does it really??), and none of them by themselves are sufficient to explain a species' response. Not to mention the fact that the samples are not really independent (they are replicates at 6 sites, repeated 3 times).  
When using method = "manyglm", the result is the one shown above. It's still a bitch to interpret - for example, what is the interpretation of an increase in abundance with both high PO4 and Secchi? Or with high NH4, but low NO3? Where are these conditions ever met?   

In fact, everything points towards the conclusion that a species response is determined by a combination of eutrophication parameters in its environment (water column characteristics), and the composition of the sediments (organic matter and granulometry).  
This is actually exactly the same thing that the PERMANOVA gives, in this particular case. However, in the future, I'm leaning more towards the modeling approach - it allows you to check the model fit to one's real data; also, there are no data reductions due to calculation of distance matrices.  




#### **Seagrass stations (Burgas Bay, 2013-2014)**  
Import zoobenthic abundance data (cleaned and prepared).  
```{r import_zoo_abnd_zostera}
zoo.abnd.zostera <- read_csv(here(save.dir, "abnd_zostera_orig_clean.csv"))

## convert station to factor (better safe than sorry later, when the stations are not plotted in the order I want them)
(zoo.abnd.zostera <- zoo.abnd.zostera %>% 
    mutate(station = factor(station, levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo")))
)
```

Remove the all-0 species (= not present in the current dataset).  
Maybe also remove the singletons (species appearing only once in the whole dataset and represented by a single individual = so rare that it's unlikely they carry important information, but it would probably improve the run times).  
```{r filter_zoo_data_zostera}
(zoo.abnd.flt.zostera <- zoo.abnd.zostera %>%
   select(-c(station:replicate)) %>%
   select(which(colSums(.) > 0))
)
```


##### **LVM - model-based ordination**
Perform a model-based unconstrained ordination by fiting a pure latent variable model (package boral - Hui et al., 2014). This will allow to visualize the multivariate stations x species data - similar to nMDS, can be interpreted in the same way.   
I'm including a (fixed) row effect to account for differences in site total abundance - this way, the ordination is in terms of **species composition**.   
NB this takes about a million years to run! 
```{r lvm_zostera}
lvm.zostera <- boral(y = zoo.abnd.flt.zostera, 
                  family = "negative.binomial",
                  
                  ## we want to control for site effects - there are 6 sites with 9 replicates each
                  row.eff = "fixed", row.ids = matrix(rep(1:5, times = c(8, 8, 4, 8, 4)), ncol = 1),  
                  ## 2 latent variables = 2 axes on which to represent the zoobenthic data
                  lv.control = list(num.lv = 2) 
                  
     #              ## example control structure, to check if function does what I want, because otherwise it takes an intolerably long time, and I'll shoot myself if I have to wait for it again
     #              mcmc.control = list(n.burnin = 10, n.iteration = 100,
     # n.thin = 1)
     #              
     
                  )

```

Check the summary and diagnostic plots for the LVM.  
```{r summary_lvm_zostera}
summary(lvm.zostera)

## model fit diagnostic plots
plot(lvm.zostera) 
```
The residuals plots look fine (no patterns in the residuals vs fitted, so variance is homogeneous, the quantile plot shows a (more or less) normal distribution of the residuals) - the model fits the data pretty well.  

Save the zostera LVM.  
```{r save_lvm_zostera}
write_rds(lvm.zostera, 
          here(save.dir, "lvm_zostera.RDS"))
```

Examine the biplot obtained by fitting the LVM, as well as the 20 most "important" species.   
```{r check_biplot_lvm_zostera}
lvsplot(lvm.zostera, jitter = T, biplot = TRUE, ind.spp = 20)
```

All in all, the final result resembles the nMDS ordination very much - same stretched clusters (Poda + Otmanli, Vromos pretty much apart, Gradina +- Ropotamo). I don't see much difference with the nMDS. 
The main difference seems to be the distance between the 2 years for Poda ana Otmanli - the LVM enlarges it. Have to remember to test for year effect! 
The run time is actually not that bad for the seagrasses.
The species singled out as significant are probably somewhat different - have to check!

Redo the biplot, because this one is not very pretty. I'm not adding the species on top, first because I'm too lazy to figure out the procedure for ordering them, and second because the plot gets too busy.   
```{r extract_lvm_coord_zostera}
## extract the LV coordinates of the stations from the model, so that the plot can be redone in ggplot 
lvs.coord.zostera <- as_tibble(lvm.zostera$lv.median)

## add the stations from the original zoobenthic table (order was not modified)
(lvs.coord.zostera <- lvs.coord.zostera %>% 
  bind_cols(zoo.abnd.zostera %>% select(station))
)

```

Make the plot and save it.  
```{r plot_lvm_zostera}
(plot.lvm.zostera <- ggplot(lvs.coord.zostera) + 
    geom_point(aes(x = lv1, y = lv2, colour = station)) + 
    scale_color_brewer(palette = "Set2", name = "station", 
                       labels = paste0("Z", as.numeric((unique(lvs.coord.zostera %>% pull(station)))))) +
   labs(x = "LV1", y = "LV2")
)

ggsave(file = here(figures.dir, "lvm_zostera.png"), 
       plot.lvm.zostera, 
       width = 15, units = "cm", dpi = 300)
```

Well, this is a weird one - this plot is flipped around 0 compared to the one that boral's plotting function gives. Otherwise nothing changes - the spatial relationships between samples are preserved. I suppose it doesn't matter much - the axes are arbitrary after all, but strange that it happens.  

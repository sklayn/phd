---
title: "Multivariate analyses of community structure (modeling)"
date: "`r Sys.Date()`"
output: html_notebook
---

This notebook contains all multivariate analyses of zoobenthic community structure using the new, nearly unheard-of modeling methods: packages mvabund, boral.  
Again, to make it self-contained, there will be the same repetitive setup/data import/preparation part.  

***  

Setup!
```{r setup, include = FALSE}
library(knitr)

knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(2, 2, .1, 2))  # smaller margin on top
})

## set the working directory to one up (all notebooks - kept in their own subdirectory within the project directory).
opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

## set knitr options for knitting code into the report.
opts_chunk$set(cache = TRUE, # save results so that code blocks aren't re-run unless code changes
               autodep = TRUE, # ..or unless a relevant earlier code block changed
               cache.comments = FALSE, # don't re-run if the only thing that changed was the comments
               highlight = TRUE, 
               small.mar = TRUE)
```

Define the working subdirectories.  
```{r workspace_setup}
## print the working directory, just to be on the safe side
paste("You are here: ", getwd())

data.dir <- "data"    ## input data files
functions.dir <- "R"  ## functions & scripts
save.dir <- "output"  ## clean data, output from models & more complex calculations
figures.dir <- "figs" ## plots & figures 
```

Import libraries.  
```{r import_packages, results = FALSE}
library(here) ## painless relative paths to subdurectories, etc.
library(tidyverse) ## data manipulation, cleaning, aggregation
library(viridis) ## smart & pretty colour schemes
library(mvabund) ## multivariate modeling analyses in ecology
library(boral) ## more multivariate modeling analyses in ecology
```

Organize some commonly-used ggplot2 modifications into a more convenient (and less repetitive) format. One day, I MUST figure out the proper way to set the theme..    
```{r custom_ggplot_settings_helpers}
## ggplot settings & things that I keep reusing
# ggplot_theme <- list(
#   theme_bw(),
#   theme(element_text(family = "Times"))
# )

## always use black-and-white theme
theme_set(theme_bw())

## helper to adjust ggplot text size & avoid repetitions 
text_size <- function(text.x = NULL,
                      text.y = NULL,
                      title.x = NULL,
                      title.y = NULL,
                      legend.text = NULL,
                      legend.title = NULL, 
                      strip.x = NULL, 
                      strip.y = NULL) {
  theme(axis.text.x = element_text(size = text.x),
        axis.text.y = element_text(size = text.y),
        axis.title.x = element_text(size = title.x),
        axis.title.y = element_text(size = title.y),
        legend.text = element_text(size = legend.text), 
        legend.title = element_text(size = legend.title), 
        strip.text.x = element_text(size = strip.x), 
        strip.text.y = element_text(size = strip.y)
        )
}


## log y/min + 1 transform - useful for species counts/biomass data visualization
log_y_min <- function(y) {
  log(y / min(y[y > 0]) + 1)
}

```

***  

#### **Sand stations (Burgas Bay, 2013-2014)**  
  Import zoobenthic abundance data (cleaned and prepared).  
```{r import_zoo_abnd_sand}
zoo.abnd.sand <- read_csv(here(save.dir, "abnd_sand_orig_clean.csv"))

## convert station to factor (better safe than sorry later, when the stations are not plotted in the order I want them)
(zoo.abnd.sand <- zoo.abnd.sand %>% 
    mutate(station = factor(station, levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva")))
)
```

Remove the all-0 species (= not present in the current dataset).  
Maybe also remove the singletons (species appearing only once in the whole dataset and represented by a single individual = so rare that it's unlikely they carry important information, but it would probably improve the run times).  
```{r filter_zoo_data_sand}
(zoo.abnd.flt.sand <- zoo.abnd.sand %>%
   select(-c(station:replicate)) %>%
   select(which(colSums(.) > 0))
)
```


##### **LVM - model-based ordination**
Perform a model-based unconstrained ordination by fiting a pure latent variable model (package boral - Hui et al., 2014). This will allow to visualize the multivariate stations x species data - similar to nMDS, can be interpreted in the same way.   
I'm including a (fixed) row effect to account for differences in site total abundance - this way, the ordination is in terms of **species composition**.   
NB this takes about a million years to run! 
```{r lvm_sand}
lvm.sand <- boral(y = zoo.abnd.flt.sand, 
                  family = "negative.binomial",
                  
                  ## we want to control for site effects - there are 6 sites with 9 replicates each
                  row.eff = "fixed", row.ids = matrix(rep(1:6, each = 9), ncol = 1),  
                  ## 2 latent variables = 2 axes on which to represent the zoobenthic data
                  lv.control = list(num.lv = 2) 
                  
     #              ## example control structure, to check if function does what I want, because otherwise it takes an intolerably long time, and I'll shoot myself if I have to wait for it again
     #              mcmc.control = list(n.burnin = 10, n.iteration = 100,
     # n.thin = 1)
     #              
     
                  )

```

Check the summary and diagnostic plots for the LVM.  
```{r summary_lvm_sand}
summary(lvm.sand)

## model fit diagnostic plots
plot(lvm.sand)
```
The residuals plots look fine (no patterns in the residuals vs fitted, so variance is homogeneous, the quantile plot shows a normal distribution of the residuals) - the model fits the data pretty well.  

Save the sand LVM.  
```{r save_lvm_sand}
write_rds(lvm.sand, 
          here(save.dir, "lvm_sand.RDS"))
```

Save the diagnostic plots.  
```{r save_diagn_plots_lvm_sand}
png(here(figures.dir, "diagnostic_lvm_sand.png"), width = 25, height = 20, units = "cm", res = 300)
par(mfrow = c(2, 2))
plot(lvm.sand)
par(mfrow = c(1, 1))
dev.off()
```



Examine the biplot obtained by fitting the LVM, as well as the 20 most "important" species.   
```{r check_biplot_lvm_sand}
lvsplot(lvm.sand, jitter = T, biplot = TRUE, ind.spp = 20)
```

All in all, the final result resembles the nMDS ordination very much - same 4 clusters (Kraimorie + Chukalya, AKin, Agalina, Sozopol + Paraskeva). Kraimorie and Chukalya are better distinguished on the LVM plot than on the MDS, but still.  
The run time is extremely, extremely long (~1h), but the data don't need to be transformed, and the model fit can be examined and adjusted if necessary.    
The species singled out as significant are probably somewhat different - have to check!   

Redo the biplot, because this one is not very pretty. I'm not adding the species on top, first because I'm too lazy to figure out the procedure for ordering them, and second because the plot gets too busy.   
```{r extract_lvm_coord_sand}
## extract the LV coordinates of the stations from the model, so that the plot can be redone in ggplot 
lvs.coord.sand <- as_tibble(lvm.sand$lv.median)

## add the stations from the original zoobenthic table (order was not modified)
(lvs.coord.sand <- lvs.coord.sand %>% 
  bind_cols(zoo.abnd.sand %>% select(station))
)

```

Make the plot and save it.  
```{r plot_lvm_sand}
(plot.lvm.sand <- ggplot(lvs.coord.sand) + 
    geom_point(aes(x = lv1, y = lv2, colour = station)) + 
    scale_color_brewer(palette = "Set2", name = "station", 
                       labels = paste0("S", as.numeric((unique(lvs.coord.sand %>% pull(station)))))) +
   labs(x = "LV1", y = "LV2")
)

```

```{r save_lvm_plot_sand}
## save the LVM plot for the sand stations
ggsave(file = here(figures.dir, "lvm_sand.png"), 
       plot.lvm.sand, 
       width = 15, units = "cm", dpi = 300)
```


##### **GLM fitting for abundance - environmental data**  
Let's fit GLMs to the sites x species matrix to try and explain the observed differences in community structure by the variation of the environmental parameters.  
These functions all come from package **mvabund**.  
Import the environmental data - the one cleaned, prepared and saved in the previous notebook (classical multivariate methods). It contains long-term averages for the water column data (2009-2011 + 2013-2014) at each station, repeated for each replicate, and the sediment data (2013-2014), again repeated to the same number of replicates. Only the variables determined to be significant by PCA are kept.       
```{r import_env_data_sand} 
env.sand <- read_csv(here(save.dir, "env_data_ordinations_sand.csv"))

## convert station to factor
(env.sand <- env.sand %>% 
    mutate(station = factor(station,
                            levels = c("Kraimorie", "Chukalya", "Akin", "Sozopol", "Agalina", "Paraskeva")))
)
```
Station is a factor, the rest of the variables are numeric.  

Turn the zoobenthic data (minus the all-0 taxa) into a matrix - easier for the mvabund package and methods to deal with.  
```{r matrix_abnd_sand}
## there is already one subset of filtered count data (54 x 147) - use it 
zoo.mvabnd.sand <- mvabund(zoo.abnd.flt.sand)
```

###### **manyGLM by LVM clusters**
First, let's see if the groups from the latent variable model (more or less equal to the clusters from the classical ordination) are valid, and which species exhibit a response.  
```{r clusters_lvm_sand}
## construct the vector of the clusters by hand, it's easier that way.. 
lvm.clusters.sand <- c(rep(1, times = 18), rep(2:4, each = 9), rep(3, times = 9))

## convert to factor
(lvm.clusters.sand <- factor(lvm.clusters.sand))
```

Check the model assumptions. 
1. Mean-variance assumption => determines the choice of family parameter. Can be checked by plotting residuals vs fits: if little pattern - the chosen mean-variance assumption is plausible.  
Another way: direct plotting (variance ~ mean), for each species within each factor
level.  
```{r check_mean_variance_lvm_sand}
plot(manyglm(zoo.mvabnd.sand ~ lvm.clusters.sand, family = "negative.binomial"))

meanvar.plot(zoo.mvabnd.sand ~ lvm.clusters.sand, table = TRUE)
```

It's not perfect, but it's not too terrible either. 

2. Assumed relationship between mean abundance and environmental variables - link function and formula.
When quantitative variables are included in the model (for now, not relevant - will be in the next model) -> if there is a trend in size of residuals at different fitted values (e.g. U-shape,..) = violation of the log-linearity assumption.
  
Everything looks more or less fine; fit the model. 
```{r fit_glms_lvm_sand}
glms.lvm.sand <- manyglm(zoo.mvabnd.sand ~ lvm.clusters.sand, 
                         family = "negative.binomial")

```

Explore the fit (residuals, diagnostic plots, etc.).  
```{r explore_glms_lvm_sand}
## residuals vs fitted values
plot(glms.lvm.sand)

## all traditional (g)lm diagnostic plots
plot.manyglm(glms.lvm.sand, which = 1:3)


# png(filename = here(figures.dir, "diag_pl_sand1.png"), width = 16, height = 10, units = "cm", res = 300)
# plot.manyglm(glms.lvm.sand, which = 2)
# dev.off()


### source mvabund GLM plotting functions modified to use a grey palette - I just can't redo these plots on my own, the function is doing too complicated things internally to scale the x and y axes
source(here(functions.dir, "default.plot.manyglm_grey.R"))
source(here(functions.dir, "plot.manyglm_grey.R"))

par(mfrow = c(2,2))
lapply(1:3, function(i) plot.manyglm.grey(glms.lvm.sand, which = i, sub.caption = ""))
par(mfrow = c(1, 1))

```

I really don't like the rainbow palette, but I would like to include these plots in my thesis results.. Will have to do something about it, just not right now.  
Update (2019/05/02): while I still think these are fugly, I have no more time or nerves to deal with it. Rainbow shit it is.  
```{r save_diagn_plots_glms_lvm_sand}
png(here(figures.dir, "diagnostic_glms_lvm_sand.png"), width = 25, height = 20, units = "cm", res = 300)
plot.manyglm(glms.lvm.sand, which = 1:3)
dev.off()
```

Save the model!  
```{r save_glms_lvm_sand}
write_rds(glms.lvm.sand, 
          here(save.dir, "glms_lvm_sand.RDS"))
```

Let's see the model summary (NB takes a LOT of time if there are many resamplings!).  
```{r summary_glms_lvm_sand}
(glms.lvm.sand.summary <- summary(glms.lvm.sand, 
                                  test = "LR", p.uni = "adjusted",
                                  nBoot = 999, ## limit the number of permutations if you just want to check it out
                                  show.time = "all")
)
```

The factor (here - groups outlined by the LVM) is highly significant according to the models.  
This also allows us to see which species exhibit a response to the chosen factor. 
The LR (likelihood ratio) statistic is used as a measure of the strength of individual taxon contributions to the observed patterns. 
I'll save the summary for safekeeping, but I'll also run an anova - to get an analysis of deviance table on the model fit (also better for extracting the species contributions, or at least I know how to do it).  
```{r save_summary_glms_lvm_sand}
write_rds(glms.lvm.sand.summary, 
          here(save.dir, "glms_lvm_sand_summary.RDS"))
```

Run the anova on the model. 
```{r anova_glms_lvm_sand}
(glms.lvm.sand.aov <- anova.manyglm(glms.lvm.sand, 
                                    test = "LR", p.uni = "adjusted", 
                                    nBoot = 999, ## limit the number of permutations for a shorter run time   
                                    show.time = "all") 
)
```
I probably shouldn't have printed all this out, but oh well who cares.  

Save the ANOVA, too.  
```{r save_anova_glms_lvm_sand}
write_rds(glms.lvm.sand.aov, 
          here(save.dir, "glms_lvm_sand_anova.RDS"))
```

NOW let's get the taxa with the highest contributions to the tested pattern (here - clusters in the LVM, which are really the different soft-bottom habitats).  
```{r relative_taxon_contrib_glms_lvm_sand}
top_n_sp_glm <- function(glms.aov, tot.dev.expl = 0.75) {
  ## helper retrieving the top n species with the highest contribution to the patterns tested by the GLMs, in decreasing order.
  ## Arguments: glms.aov - results from an ANOVA on the fitted GLMs
  ##            dev.explained - proportion of explained deviance to use as cutoff
  
  ## get the change in deviance due to the tested pattern (= 2nd row from table of univariate test stats), and sort the species in order of decreasing contribution
  uni.sorted <- sort(glms.aov$uni.test[2, ], decreasing = TRUE, index.return = FALSE)

  ## start at 10 species and check how much of the deviance is explained by their contributions. Repeat, increasing by increments of 10 until the desired explained deviance (set at function call) is reached. 
  top.n.sp <- 10
  dev.expl <- sum(uni.sorted[1:top.n.sp])/sum(uni.sorted)
  
  while(dev.expl < tot.dev.expl) {
    top.n.sp <- top.n.sp + 10
    dev.expl <- sum(uni.sorted[1:top.n.sp])/sum(uni.sorted)
  }
  
  ## print the total deviance explained - just for information
  print(paste("Total deviance explained:", round(dev.expl, 3)))
  
  ## return the final top species (and their univariate contributions, just in case) 
  top.sp <- uni.sorted[1:top.n.sp]
  return(top.sp)
}

## get the top contributing species for the initial sand GLMs 
(top.sp.glms.lvm.sand <- top_n_sp_glm(glms.lvm.sand.aov, tot.dev.expl = 0.75)
)

## unfortunately, mvabund likes to rename my species when converting the data to matrix (no spaces in names), and since I'm going to look them up in my initial untransformed count data, I have to change them back..   
names(top.sp.glms.lvm.sand) <- names(top.sp.glms.lvm.sand) %>% 
  str_replace(pattern = "\\.", replacement = " ")

top.sp.glms.lvm.sand
```

Try to plot these top contributing species - for whatever that's worth, because 50 species on a plot is a monstrosity.  

```{r plot_relative_taxon_contrib_glms_lvm_sand}
## get the species and their abundances from the original count data, and transform them to long format
(abnd.top.sp.glms.lvm.sand <- zoo.abnd.sand %>% 
   select(station, names(top.sp.glms.lvm.sand)) %>% 
   gather(key = "species", value = "count", -station) %>% 
   ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
   mutate(species = factor(species, levels = rev(names(top.sp.glms.lvm.sand))))
)

plot_top_n <- function(top.n.sp.data, mapping, labs.legend, lab.y, palette) {
  ## helper for plotting top n species. Was hoping to avoid repeating it from way back when, but no dice. 
  ## Arguments: top.n.sp.data - data frame (long) of top species' counts/biomasses at the different stations
  ##            mapping - mappings of the aesthetics
  ##            labs.legend - labels the use for the legend entries
  ##            lab.y - custom label for y axis
  ##            palette - custom colour palette (for consistency with other plots)
  
  ggplot(top.n.sp.data, mapping) +
    geom_point(alpha = 0.75) + # make points larger & partially transparent
    scale_color_brewer(palette = palette,  labels = labs.legend) + 
    ylab(lab.y) + 
    coord_flip() 
}


(plot.top.sp.glms.lvm.sand <- plot_top_n(abnd.top.sp.glms.lvm.sand,
                                         mapping = aes(x = species, y = log_y_min(count), colour = station),
                                         labs.legend = paste0("S", as.numeric(unique(abnd.top.sp.glms.lvm.sand$station))),
                                         lab.y = "Abundance (log(y/min + 1))",
                                         palette = "Set2"
                                        ) +
    theme(legend.position = "top")

)
```

Well this is a nightmarish plot.. I'll probably just put this awfulness in a table and call it a day, or play with lvsplot and the modeled ordination plot, if a plot is what's needed.  

Extract the top-contributing species to each cluster (this same nightmare above, but as a table). This chunk is hopelessly ugly and clumsy (and I'll have to repeat it for the seagrass, too!), but I'm tired of being stuck on this. I still have many, MANY more things to do, and more time-consuming ones too..  
```{r table_relative_taxon_contrib_glms_lvm_sand}
top_sp_glms_table <- function(manyglms.obj.smry, group, p = 0.05) {
  ### extracts the top species in a group for which there is an observed effect in a manyglm test, at the specified probability level.
  ### Returns: tibble with the top species for the specified group/cluster, sorted (descending) by univariate LR value of the species, significant at the given p level. 
  
  ## extract the univariate LR coefficients of the species and their p-values 
  sp_univar <- as_tibble(manyglms.obj.smry$uni.test, rownames = "species")
  sp_p <- as_tibble(manyglms.obj.smry$uni.p, rownames = "species")

  ## combine in the same tibble
  sp_all <- left_join(sp_univar, sp_p, by = "species")  
  
  ## rename the columns
  sp_all <- sp_all %>% 
    rename_at(vars(contains(".x")), list(~str_replace_all(., pattern = ".x", ".LR"))) %>% 
    rename_at(vars(contains(".y")), list(~str_replace_all(., pattern = ".y", ".p")))
  
  ## filter only the group/cluster we want, at the p-level we want
  sp_all_flt <- sp_all %>% 
    select(species, contains(group)) %>% 
    filter_at(vars(contains(".p")), all_vars(. < p)) %>%
    arrange_at(vars(contains(".LR")), list(~desc(.)))

}

top.sp.abnd.glms.lvm.sand <- lapply(names(glms.lvm.sand.summary$aliased), function(x) top_sp_glms_table(glms.lvm.sand.summary, x, p = 0.05)) 

## fix species names (remove dot) 
top.sp.abnd.glms.lvm.sand <- lapply(top.sp.abnd.glms.lvm.sand, function(x) x %>% mutate(species = str_replace(species, pattern = "\\.", replacement = " ")))

## rename columns (= group names) - right now they are something like "lvm.clusters.sand2" etc.
top.sp.abnd.glms.lvm.sand <- lapply(top.sp.abnd.glms.lvm.sand, function(x) x %>% rename_at(vars(contains("lvm.clusters.sand")), list(~str_replace_all(., pattern = "lvm.clusters.sand", "group_"))))

top.sp.abnd.glms.lvm.sand <- lapply(top.sp.abnd.glms.lvm.sand, function(x) x %>% rename_at(vars(contains("Intercept")), list(~str_replace_all(., pattern = "\\(Intercept\\)", "group_1"))))


## pull the abundances from the original count df and add to the summary glm tables 
## make a long df of abundances & add clusters  
zoo.abnd.sand.long <- zoo.abnd.sand %>%
  select(-c(month:replicate)) %>%
  gather(key = "species", value = "count", -station) %>% 
  mutate(group = case_when(station %in% c("Kraimorie", "Chukalya") ~ 1, 
                           station == "Akin" ~ 2, 
                           station %in% c("Sozopol", "Paraskeva") ~ 3, 
                           station == "Agalina" ~ 4))

## sum sp abundances by group; nest by group
zoo.abnd.sand.long.smry <- zoo.abnd.sand.long %>% 
  group_by(species, group) %>% 
  summarise(total_count = sum(count)) %>% 
  group_by(group) %>%
  nest()

## add the counts to the group dfs - wow that's an ugly, ugly hack. Wish I had more time to write this up properly.. 
top.sp.abnd.glms.lvm.sand <- map2(top.sp.abnd.glms.lvm.sand, zoo.abnd.sand.long.smry %>% pull(group), ~left_join(.x, zoo.abnd.sand.long.smry %>% filter(group == .y) %>% unnest(), by = "species"))

## since these are sum counts over all the replicates (that's why the monstrous numbers), average them to be mean counts per group. NB different groups consist of different numbers of replicates, b.c. some groups consist of more than one station
(top.sp.abnd.glms.lvm.sand <- map2(top.sp.abnd.glms.lvm.sand, c(18, 9, 18, 9), function(x, y) x %>% mutate(mean_count = total_count/y))
)
```

To determine the relative taxon contribution to patterns: LR statistic - a measure of strength of individual taxon contributions. LR expresses how many times more likely the data are under one model than the other. This likelihood ratio, or equivalently its logarithm, can then be used to compute a p-value, or, compared to a critical value, to decide whether to reject the null model in favour of the alternative model.  

In this case, the model shows which species exhibit a reaction based on the chosen groups - in other words, which species are more likely to be more/less abundant in each group.  
For **group 1** (= S1-S2), the species/taxa with significantly **higher abundance** are: Oligochaeta, H. filiformis, P. kefersteini, M. palmata, P. cirrifera, A. diadema (among others); and the ones with significantly **lower abundance** - even 0, in some cases - S. bidentata, B.lanceolatum, M. papillicornis, Melita palmata, P. jubatus, and so on.  
For **group 2** (= S3), the species with **higher abundance** are: B. lanceolatum, O. limacina, Oligochaeta (this is this strange artifact of 2013), P. kefersteini, L. flavocapitatus. The species with **lower abundance** are: H. filiformis, A. kagoshimensis, M. stammeri, Melinna palmata, etc.
For **group 3** (= S4-S6), the species with **higher abundance** are: C. gallina, L. mediterraneum - with very high dominance over practically all others; also Pseudocuma longicorne, Spio filicornis. The species with **lower abundance** are: H. filiformis, Oligochaetes (to a certain extent - they are still present, though), A. kagoshimensis, L. koreni, Harmothoe reticulata, Iphinoe tenella, Leiochone leiopygos.  
For **group 4** (= S5), the species with **higher abundance** are: Microdeutopus versiculatus, Eurydice dollfusi, Melita palmata, Polygordius neapolitanus, Polycirrus caliendrum, Polycirrus jubatus, Streptosyllis bidentata. The species with **lower abundance** are: A. kagoshimensis, Melinna palmata, P. cirrifera, P. ciliata, A. alba, I. tenella.   
I love how the species with the highest variances (e.g. C. gallina, the most conspicuous example) are consistently pushed back - have lower LR scores. This is very good - C. gallina in particular is dominant in group 3, but is present also in all other groups - its substrate/depth preferences are very wide, so this is not uncommon. It's not automatically pushed to the top of the list, but its reaction is detected by the manyGLM test. Neat! 
Contrast to the SIMPER results, where the species with the highest variance are consistently at the top - they contribute the most to the similarity, as per the test definition.  

I'm going to save these as separate files (manually), then format them as tables - I know it's a shame, but I'm too frustrated to figure out how to do it programmatically.  
I'll also put them in a word table in my final text, because I don't want to deal with a million separate ones (embedded excel tables don't split over multiple pages).  

**NB In my text, I'm switching the names/places of group 3 and 4, to be consistent with the SIMPER groups (I'm NOT going to repeat all this just to have the numbers match up). So the file names, table names, etc. remain as above. But in the text, I'll have the following: group 1 = S1-S2, group 2 = S3, group 3 = S5, group 4 = S4-S6. REMEMBER THIS SO THERE IS NO CONFUSION!**


###### **manyGLM by environmental parameters**  
Now, let's try to see a different thing - which environmental parameters best describe the species response.  
I'm going to use the PCA-filtered environmental data - it's still going to be a slog, with 7 potential predictors..  
First, construct the formula for the model - will do it separately in case I need to update it later, etc. This is the full formula with all explanatory variables.    
```{r formula_env_manyglm_full_sand}
(formula.env.glms.sand <- formula(paste("zoo.mvabnd.sand ~", 
                                        paste(env.sand %>% select(-station) %>% names(), collapse = "+")))
)
```

Fit the GLMs to the sand abundance data. 
```{r fit_glms_env_full_sand}
env.glms.sand <- manyglm(formula.env.glms.sand,
                         data = env.sand,
                         family = "negative.binomial")

```

Explore the fit (residuals, diagnostic plots, etc.).  
```{r explore_glms_env_full_sand}
## residuals vs fitted values
plot(env.glms.sand)


## all traditional (g)lm diagnostic plots
plot.manyglm(env.glms.sand, which = 1:3)

```

Well, it's good enough if you ask me (still the kinda strange "line" at lin.pred = -6; otherwise residuals are random enough).  

Save the model!  
```{r save_glms_env_full_sand}
write_rds(env.glms.sand, 
          here(save.dir, "glms_env_sand.RDS"))
```


Before anything else, I want to try and reduce the model a little - to improve the fit/reduce run time.  
The automatic step functions that eliminate/add model terms sequentially don't work - they fail at the last step with a cryptic error about differing numbers of rows - I assume because manyglm has as left side term the whole community abundance matrix, and the functions don't really know how to deal with that. I don't understand enough about their internals to fix the problem, so I'm just going to write my own little automation based on the function drop1.  
```{r evaluate_glms_env_function}
evaluate_glms_env <- function(full.mod) {
  ### sequentially eliminate model terms in manyglms vs environmental parameters, and find the best model based on lowest AIC score.
  ### Arguments: full.mod - full model fit
  ### Returns: best manyglm model of environmental parameters; prints out the best model formula
  ### Dependencies: tidyverse   
  

  ## get the starting formula (= full model with all variables)
  start.formula <- formula(full.mod)

  drop_var <- function(mod) {
    ### helper picking the next variable to drop from a model to improve the fit (based on AIC)
    
    ## check the model AICs if variables are dropped one by one
    drop1.df <- as_tibble(drop1(mod), rownames = "drop_var") %>% arrange(AIC)
    
    ## pick the variable to drop next - the one resulting in the largest decrease in AIC
    drop.var <- drop1.df %>% filter(AIC == min(AIC)) %>% pull(drop_var)
    return(drop.var)
  }
  
  ## pick the variable to drop next
  drop.var <- drop_var(full.mod)

  if(drop.var != "<none>") {
     ## update the model formula, dropping the variable resulting in the largest decrease in AIC; then apply it to the model.
    new.formula <- update.formula(start.formula, paste0("~. -", drop.var))
    new.mod <- update(full.mod, new.formula)

    ## identify a new variable to drop that lowers the AIC
    drop.var <- drop_var(new.mod)
    
    ## repeat the steps above until the function can no longer find such a variable (i.e., dropping more variables doesn't improve the model fit)
    while(drop.var != "<none>") {
      new.formula <- update.formula(new.formula, paste0("~. -", drop.var))
      new.mod <- update(full.mod, new.formula)
      drop.var <- drop_var(new.mod)
    }
    
    ## print out the best model formula
    print(paste("Best model: ", paste(deparse(new.formula), collapse = "")))
    return(new.mod)
    
  } else {
    ## if the starting model is the best, print its formula (fat chance!)
    print(paste("Best model: ", paste(deparse(start.formula), collapse = "")))
    return(full.mod)
  }
  
}

```


Select the best reduced model of environmental variables for the sand stations.  
```{r select_top_glm_env_sand}
top.env.glm.red.sand <- evaluate_glms_env(env.glms.sand)

```

Check its fit. 
```{r explore_top_glm_env_red_sand}
## residuals vs fitted values
plot(top.env.glm.red.sand)

## all traditional (g)lm diagnostic plots
plot.manyglm(top.env.glm.red.sand, which = 1:3)
```

I think it's fine; might even be better than the full model.. 
Save it, too. 
```{r save_top_glm_env_red_sand}
write_rds(top.env.glm.red.sand, 
          here(save.dir, "glms_top_env_red_sand.RDS"))
```

Save the model diagnostic plots.  

```{r save_diagn_plots_top_glm_env_red_sand}
png(here(figures.dir, "diagnostic_top_glm_env_red_sand.png"), width = 25, height = 20, units = "cm", res = 300)
plot.manyglm(top.env.glm.red.sand, which = 1:3)
dev.off()
```


Run ANOVA on this model.
```{r anova_top_glm_env_red_sand}
(top.env.glm.red.sand.aov <- anova.manyglm(top.env.glm.red.sand,
                                           test = "LR", p.uni = "adjusted",
                                           nBoot = 999, ## limit the number of permutations for a shorter run time   
                                           show.time = "all") 
)
```

So, it turns out that the long-term water column eutrophication (PO4, seston), the anthropogenic pressure in general (LUSI), and the sediment composition (gravel) explain the observed community patterns best. 

Save the ANOVA - I really, really don't want to have to repeat it.  
```{r save_anova_top_glm_env_red_sand}
write_rds(top.env.glm.red.sand.aov, 
          here(save.dir, "glms_top_env_red_sand_anova.RDS"))
```

Get the taxa with the highest contributions to the tested pattern (here - species most affected by changes in water/environmental quality parameters).  
```{r relative_taxon_contrib_top_glm_env_red_sand}
## get the top contributing species for the environmental parameter sand GLMs 
(top.sp.glms.env.red.sand <- top_n_sp_glm(top.env.glm.red.sand.aov, tot.dev.expl = 0.75)
)

## unfortunately, mvabund likes to rename my species when converting the data to matrix (no spaces in names), and since I'm going to look them up in my initial untransformed count data, I have to change them back..   DON'T BE IN A HURRY TO DO THAT IF YOU WANT TO SUBSET THE ORIGINAL MATRIX BEFORE RUNNING TRAITGLM 
names(top.sp.glms.env.red.sand) <- names(top.sp.glms.env.red.sand) %>% 
  str_replace(pattern = "\\.", replacement = " ")

```

I'm going to plot these top contributing species, but I'm (probably) not using the plot. At least this time it's more manageable, but still not presentable enough.. 

```{r plot_relative_taxon_contrib_top_glm_env_red_sand}
## get the species and their abundances from the original count data, and transform them to long format
abnd.top.sp.glms.env.red.sand <- zoo.abnd.sand %>% 
  select(station, names(top.sp.glms.env.red.sand)) %>% 
  gather(key = "species", value = "count", -station) %>% 
  ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
  mutate(species = factor(species, levels = rev(names(top.sp.glms.env.red.sand)))) %>% 
  ## add clusters from LVM as a column
  mutate(group = case_when(station %in% c("Kraimorie", "Chukalya") ~ 1,
                           station == "Akin" ~ 2, 
                           station %in% c("Sozopol", "Paraskeva") ~ 3, 
                           station == "Agalina" ~ 4))



## add the significant environmental parameters from the model
(abnd.top.sp.glms.env.red.sand <- left_join(abnd.top.sp.glms.env.red.sand, 
                                            env.sand %>% select(station, PO4, seston, LUSI, gravel), 
                                            by = "station") 
    
)


(plot.top.sp.glms.env.red.sand <- plot_top_n(abnd.top.sp.glms.env.red.sand,
                                             mapping = aes(x = species, y = log_y_min(count), colour = factor(group)),
                                             labs.legend = unique(abnd.top.sp.glms.env.red.sand$group),
                                             lab.y = "Abundance (log(y/min + 1))",
                                             palette = "Set2") + 
    theme(legend.position = "top")
)
```

Try another thing - manually, unfortunately: this same nightmare, but colored by the values of each model term. 
```{r plot_relative_taxon_contrib_top_glm_env_red_sand_by_param}
ggplot(abnd.top.sp.glms.env.red.sand,
       mapping = aes(x = species, y = log_y_min(count), colour = seston)) + 
  geom_point() + 
  coord_flip()
```

Well, in the end the results presented as a table (as below) went into the thesis text, but I want to try and make a plot with less species (~10-15) for the defense presentation - in the end, it's more illustrative and easier to understand. Unfortunately, this still means 4 plots - for each environmental factor in the model.  
```{r extract_top10_taxa_glm_env_red_sand}
## since the top contributing taxa are already extracted, I'll just get the original abundances of the top 10 (or 15) in the vector  
## get the selected species and their abundances from the original count data, and transform them to long format
abnd.top10.sp.glms.env.red.sand <- zoo.abnd.sand %>% 
  select(station, names(top.sp.glms.env.red.sand[1:10])) %>% 
  gather(key = "species", value = "count", -station) %>% 
  ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
  mutate(species = factor(species, levels = rev(names(top.sp.glms.env.red.sand)))) 


## add the significant environmental parameters from the model
(abnd.top10.sp.glms.env.red.sand <- left_join(abnd.top10.sp.glms.env.red.sand, 
                                              env.sand %>% select(station, PO4, seston, LUSI, gravel), 
                                              by = "station") 
    
)
```

Now make a plot of species abundances, coloring them by environmental factor values (4 plots in total).  
```{r plot_top10_taxa_glm_env_red_sand_by_param}
(plots.list.top10.taxa.glm.env.red.sand <- lapply(c("PO4", "seston", "LUSI", "gravel"),
                                                  function (i) {
                                                   ggplot(abnd.top10.sp.glms.env.red.sand,
                                                          aes_(x = ~species, y = ~log_y_min(count), colour = as.name(i))) +
                                                     # scale_colour_viridis(option = "viridis") +
                                                     geom_point() +
                                                     coord_flip() + 
                                                     labs(x = "", y = "Abundance (log(y/min + 1))")
                                                   }
                                                 ) 
)


## set the names of the plots in the list - will be easier to save them in one go later (less fiddling with constructing file names)
names(plots.list.top10.taxa.glm.env.red.sand) <- c("PO4", "seston", "LUSI", "gravel")

```


Save these plots.. 
```{r save_plots_top10_taxa_glm_env_red_sand_by_param}
map2(names(plots.list.top10.taxa.glm.env.red.sand),
     plots.list.top10.taxa.glm.env.red.sand, 
     function(a, b) {
       ggsave(filename = here(figures.dir, paste0("top10_taxa_glm_env_red_sand_", a, ".png")),
              b, 
              width = 15, height = 10, units = "cm", dpi = 300)
       })
```


Extract the taxon information (univariate tests) from the model ANOVA to present as a table (probably better than this plot, although it's informative).  
```{r table_relative_taxon_contrib_top_glm_env_red_sand}
## extract the univariate test coefficients (LR) from the environmental model ANOVA. NB keep the row names when converting the matrix to tibble! 
table.top.sp.glms.env.red.sand <- as_tibble(top.env.glm.red.sand.aov$uni.test, rownames = "var")

## fix the species names - remove first dot  
names(table.top.sp.glms.env.red.sand) <- names(table.top.sp.glms.env.red.sand) %>% 
  str_replace(pattern = "\\.", replacement = " ")

## subset only the top species (explaining ~75% of the dataset variation)
table.top.sp.glms.env.red.sand <- table.top.sp.glms.env.red.sand %>% 
  select(var, names(top.sp.glms.env.red.sand))

## transpose, because a table with 50 columns is just unreadable
(table.top.sp.glms.env.red.sand <- table.top.sp.glms.env.red.sand %>%
    gather(key = species, value = value, -var) %>% 
    spread(key = var, value = value) %>% 
    ## arrange as before (terms in the order they appear in the model, and by descending value of the LR for the first model term - here, PO4). Also get rid of the intercept (it's all-NA anyway).
    select(species, PO4, seston, LUSI, gravel) %>%
    arrange(desc(PO4)) 
)
```

Save this to a file - will have to format it as a nice table by hand, unfortunately. 
```{r save_table_relative_taxon_contrib_top_glm_env_red_sand}
write_csv(table.top.sp.glms.env.red.sand, 
          here(save.dir, "taxa_contrib_glms_top_env_red_sand.csv"))
```


Calculate the percentage contribution of each of these species to each of the model terms (Dev(term) = Sum-of-LR - sum of the LRs for the individual univariate species tests).. 
```{r table_prop_relative_taxon_contrib_top_glm_env_red_sand}
## get the total deviance (Sum-of-LR) for each model term
(dev.terms.top.glms.env.sand <- as_tibble(top.env.glm.red.sand.aov$table, rownames = "var") %>%
   ## get rid of unnecessary variables (I only want the deviance value for each term) and intercept term 
   select(var, Dev) %>% 
   filter(var != "(Intercept)") %>% 
   ## transpose 
   gather(variable, value, -var) %>%
   spread(var, value) %>% 
   ## get rid of first column and rearrange columns to match table of deviances of univariate tests for species 
   select(-variable) %>% 
   select(PO4, seston, LUSI, gravel)
)  

## calculate the proportion contribution of each species to each parameter deviance
prop.top.sp.glms.env.red.sand <- map2_df(table.top.sp.glms.env.red.sand %>% select(-species),
                                         dev.terms.top.glms.env.sand, 
                                         ~.x/.y)

## add back the species 
(prop.top.sp.glms.env.red.sand <- bind_cols(table.top.sp.glms.env.red.sand %>% select(species), 
                                            prop.top.sp.glms.env.red.sand)
)

```


Final analysis to try: which species respond differently to different environmental parameters?
(= traits analysis - fit single predictive model for all species at all sites, but w/o attempting to explain the different responses using traits - the species ID is used in place of a traits matrix).  
NB only use the top species that exhibited a reaction in the environmental model fit (= the ones accounting for ~75% of the total variability), and only the significant predictors - to improve run times.   
```{r sp_response_top_glm_env_red_sand}
sp.response.glms.env.red.sand <- traitglm(L = mvabund(zoo.abnd.flt.sand[, names(top.sp.glms.env.red.sand)]), 
                                          R = as.matrix(env.sand %>% select(PO4, seston, LUSI, gravel)), 
                                          method = "manyglm")


sp.response.glms.env.red.sand$fourth.corner


# plot this 
a <- max(abs(sp.response.glms.env.red.sand$fourth.corner))
colort <- colorRampPalette(c("blue","white","red")) 
plot.spp <- lattice::levelplot(t(as.matrix(sp.response.glms.env.red.sand$fourth.corner)), xlab = "Environmental Variables",
                     ylab = "Species", col.regions = colort(100), at = seq(-a, a, length = 100),
                     scales = list(x = list(rot = 45)))
print(plot.spp)
```

When using LASSO (method = "glm1path"), the algorithm fails to converge - I'm not sure how to interpret it.. Maybe because the function tests each individual species:env.parameter interaction (does it really??), and none of them by themselves are sufficient to explain a species' response. Not to mention the fact that the samples are not really independent (they are replicates at 6 sites, repeated 3 times).  
When using method = "manyglm", the result is the one shown above. It's still a bitch to interpret - for example, what is the interpretation of an increase in abundance with for ex. high PO4, but low LUSI? Where are these conditions ever met?   

In fact, everything points towards the conclusion that a species response is determined by a combination of eutrophication parameters in its environment (water column characteristics), and the composition of the sediments (organic matter and granulometry).  

This is actually sort of similar to the PERMANOVA results, in this particular case. However, it's much more parsimonious.  
In the future, I'm leaning more towards the modeling approach - it allows you to check the model fit to one's real data; also, there are no data reductions due to calculation of distance matrices.  



#### **Seagrass stations (Burgas Bay, 2013-2014)**  
Import zoobenthic abundance data (cleaned and prepared).  
```{r import_zoo_abnd_zostera}
zoo.abnd.zostera <- read_csv(here(save.dir, "abnd_zostera_orig_clean.csv"))

## convert station to factor (better safe than sorry later, when the stations are not plotted in the order I want them)
(zoo.abnd.zostera <- zoo.abnd.zostera %>% 
    mutate(station = factor(station, levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo")))
)
```

Remove the all-0 species (= not present in the current dataset).  
Maybe also remove the singletons (species appearing only once in the whole dataset and represented by a single individual = so rare that it's unlikely they carry important information, but it would probably improve the run times).  
```{r filter_zoo_data_zostera}
(zoo.abnd.flt.zostera <- zoo.abnd.zostera %>%
   select(-c(station:replicate)) %>%
   select(which(colSums(.) > 0))
)
```


##### **LVM - model-based ordination**
Perform a model-based unconstrained ordination by fitting a pure latent variable model (package boral - Hui et al., 2014). This will allow to visualize the multivariate stations x species data - similar to nMDS, can be interpreted in the same way.   
I'm including a (fixed) row effect to account for differences in site total abundance - this way, the ordination is in terms of **species composition**.   
NB this takes about a million years to run! 
```{r lvm_zostera}
lvm.zostera <- boral(y = zoo.abnd.flt.zostera, 
                  family = "negative.binomial",
                  
                  ## we want to control for site effects - there are 5 sites; some with 8, some with 4 replicates
                  row.eff = "fixed", row.ids = matrix(rep(1:5, times = c(8, 8, 4, 8, 4)), ncol = 1),  
                  ## 2 latent variables = 2 axes on which to represent the zoobenthic data
                  lv.control = list(num.lv = 2) 
                  
     #              ## example control structure, to check if function does what I want, because otherwise it takes an intolerably long time, and I'll shoot myself if I have to wait for it again
     #              mcmc.control = list(n.burnin = 10, n.iteration = 100,
     # n.thin = 1)
     #              
     
                  )

```

Check the summary and diagnostic plots for the LVM.  
```{r summary_lvm_zostera}
summary(lvm.zostera)

## model fit diagnostic plots
plot(lvm.zostera) 
```
The residuals plots look fine (no patterns in the residuals vs fitted, so variance is homogeneous, the quantile plot shows a (more or less) normal distribution of the residuals) - the model fits the data pretty well.  

Save the zostera LVM.  
```{r save_lvm_zostera}
write_rds(lvm.zostera, 
          here(save.dir, "lvm_zostera.RDS"))
```

Save the diagnostic plots.  
```{r save_diagn_plots_lvm_zostera}
png(here(figures.dir, "diagnostic_lvm_zostera.png"), width = 25, height = 20, units = "cm", res = 300)
par(mfrow = c(2, 2))
plot(lvm.zostera)
par(mfrow = c(1, 1))
dev.off()
```


Examine the biplot obtained by fitting the LVM, as well as the 20 most "important" species.   
```{r check_biplot_lvm_zostera}
lvsplot(lvm.zostera, jitter = T, biplot = TRUE, ind.spp = 20)
```

All in all, the final result resembles the nMDS ordination very much - same stretched clusters (Poda + Otmanli, Vromos pretty much apart, Gradina +- Ropotamo). I don't see much difference with the nMDS. 
The main difference seems to be the distance between the 2 years for Poda ana Otmanli - the LVM enlarges it. Have to remember to test for year effect! 
The run time is actually not that bad for the seagrasses.
The species singled out as significant are probably somewhat different - have to check!

Redo the biplot, because this one is not very pretty. I'm not adding the species on top, first because I'm too lazy to figure out the procedure for ordering them, and second because the plot gets too busy.   
```{r extract_lvm_coord_zostera}
## extract the LV coordinates of the stations from the model, so that the plot can be redone in ggplot 
lvs.coord.zostera <- as_tibble(lvm.zostera$lv.median)

## add the stations from the original zoobenthic table (order was not modified)
(lvs.coord.zostera <- lvs.coord.zostera %>% 
  bind_cols(zoo.abnd.zostera %>% select(station))
)

```

Make the plot and save it.  
```{r plot_lvm_zostera}
(plot.lvm.zostera <- ggplot(lvs.coord.zostera) + 
    geom_point(aes(x = lv1, y = lv2, colour = station)) + 
    scale_color_brewer(palette = "Set2", name = "station", 
                       labels = paste0("Z", as.numeric((unique(lvs.coord.zostera %>% pull(station)))))) +
   labs(x = "LV1", y = "LV2")
)

```

Well, this is a weird one - this plot is flipped around 0 compared to the one that boral's plotting function gives. Otherwise nothing changes - the spatial relationships between samples are preserved. I suppose it doesn't matter much - the axes are arbitrary after all, but strange that it happens.  

```{r save_plot_lvm_zostera}
## save the LVM plot for the seagrass
ggsave(file = here(figures.dir, "lvm_zostera.png"), 
       plot.lvm.zostera, 
       width = 15, height = 10, units = "cm", dpi = 300)
```

##### **GLM fitting for abundance - environmental data**  
Fit GLMs to the sites x species matrix to try and explain the observed differences in community structure by the variation of the environmental parameters.  
These functions all come from package **mvabund**.  
Import the environmental data - the one cleaned, prepared and saved in the previous notebook (classical multivariate methods). It contains long-term averages for the water column data (as long-term as available, at least) at each station, repeated for each replicate, the sediment data (2013-2014), and the seagrass data (2013-2014), again repeated to the same number of replicates. Only the variables determined to be significant by PCA are kept.       
```{r import_env_data_zostera} 
env.zostera <- read_csv(here(save.dir, "env_data_ordinations_zostera.csv"))

## convert station to factor
(env.zostera <- env.zostera %>% 
    mutate(station = factor(station,
                            levels = c("Poda", "Otmanli", "Vromos", "Gradina", "Ropotamo")))
)
```
Station is a factor, the rest of the variables are numeric.  

Turn the zoobenthic data (minus the all-0 taxa) into a matrix - easier for the mvabund package and methods to deal with.  
```{r matrix_abnd_zostera}
## there is already one subset of filtered count data (32 x 94) - use it 
zoo.mvabnd.zostera <- mvabund(zoo.abnd.flt.zostera)
```

###### **manyGLM by LVM clusters**
First, let's see if the groups from the latent variable model (more or less equal to the clusters from the classical ordination) are valid, and which species exhibit a response.  
I'm going to try something new here - 1) loose clusters from the LVM ordination, 1 = Poda-Otmanli, 2 = Vromos, 3 = Gradina-Ropotamo. 2) stations as clusters, as I did before for the seagrass data, although I don't believe it's valid/justified to do so... 3) another possible configuration of clusters from the LVM ordination: 1 = Z1-Z2, 2 = Z3, 3 = Z4, 4 = Z5.   
```{r clusters_lvm_zostera}
## construct the vectors of the clusters by hand - first, situation 1 above
lvm.clusters.zostera.1 <- rep(1:3, times = c(16, 4, 12))
(lvm.clusters.zostera.1 <- factor(lvm.clusters.zostera.1))

## again, for case 2
lvm.clusters.zostera.2 <- rep(1:5, times = c(8, 8, 4, 8, 4))
(lvm.clusters.zostera.2 <- factor(lvm.clusters.zostera.2))

## again, for case 3
lvm.clusters.zostera.3 <- rep(1:4, times = c(16, 4, 8, 4))
(lvm.clusters.zostera.3 <- factor(lvm.clusters.zostera.3))
```

**LVM clusters - case 1**
Check the model assumptions. 
1. Mean-variance assumption => determines the choice of family parameter. Can be checked by plotting residuals vs fits: if little pattern - the chosen mean-variance assumption is plausible.  
Another way: direct plotting (variance ~ mean), for each species within each factor
level.  
```{r check_mean_variance_lvm_zostera_1}
plot(manyglm(zoo.mvabnd.zostera ~ lvm.clusters.zostera.1, family = "negative.binomial"))

meanvar.plot(zoo.mvabnd.zostera ~ lvm.clusters.zostera.1, table = TRUE)
```

It's not perfect, but it's not too terrible either. 

2. Assumed relationship between mean abundance and environmental variables - link function and formula.
When quantitative variables are included in the model (for now, not relevant - will be in the next model) -> if there is a trend in size of residuals at different fitted values (e.g. U-shape,..) = violation of the log-linearity assumption.
  
Everything looks more or less fine; fit the model. 
```{r fit_glms_lvm_zostera_1}
glms.lvm.zostera.1 <- manyglm(zoo.mvabnd.zostera ~ lvm.clusters.zostera.1, 
                              family = "negative.binomial")

```

Explore the fit (residuals, diagnostic plots, etc.).  
```{r explore_glms_lvm_zostera_1}
## residuals vs fitted values
plot(glms.lvm.zostera.1)

## all traditional (g)lm diagnostic plots
plot.manyglm(glms.lvm.zostera.1, which = 1:3)
```

I really don't like the rainbow palette, but I would like to include these plots in my thesis results.. Will have to do something about it, just not right now.  
Save the model!  
```{r save_glms_lvm_zostera_1}
write_rds(glms.lvm.zostera.1, 
          here(save.dir, "glms_lvm_zostera_1.RDS"))
```


Let's see the model summary (NB takes a LOT of time if there are many resamplings!).  
```{r summary_glms_lvm_zostera_1}
(glms.lvm.zostera.1.summary <- summary(glms.lvm.zostera.1, 
                                  test = "LR", p.uni = "adjusted",
                                  nBoot = 999, ## limit the number of permutations if you just want to check it out
                                  show.time = "all")
)
```

The factor is highly significant according to the models.  
This also allows us to see which species exhibit a response to the chosen factor. 
The LR (likelihood ratio) statistic is used as a measure of the strength of individual taxon contributions to the observed patterns. 
I'll save the summary for safekeeping, but I'll also run an anova - to get an analysis of deviance table on the model fit (also better for extracting the species contributions, or at least I know how to do it).  
```{r save_summary_glms_lvm_zostera_1}
write_rds(glms.lvm.zostera.1.summary, 
          here(save.dir, "glms_lvm_zostera_1_summary.RDS"))
```

Run the anova on the model. 
```{r anova_glms_lvm_zostera_1}
(glms.lvm.zostera.1.aov <- anova.manyglm(glms.lvm.zostera.1, 
                                    test = "LR", p.uni = "adjusted", 
                                    nBoot = 999, ## limit the number of permutations for a shorter run time
                                    pairwise.comp = ~lvm.clusters.zostera.1, ## check the pairwise comparison between clusters
                                    show.time = "all") 
)
```

Aaaand the differences between clusters are highly significant in this iteration.. 

Save the ANOVA, too.  
```{r save_anova_glms_lvm_zostera_1}
write_rds(glms.lvm.zostera.1.aov, 
          here(save.dir, "glms_lvm_zostera_1_anova.RDS"))
```

NOW let's get the taxa with the highest contributions to the tested pattern.  
```{r relative_taxon_contrib_glms_lvm_zostera_1}
## get the top contributing species for the initial zostera GLMs 
(top.sp.glms.lvm.zostera.1 <- top_n_sp_glm(glms.lvm.zostera.1.aov, tot.dev.expl = 0.75)
)

## unfortunately, mvabund likes to rename my species when converting the data to matrix (no spaces in names), and since I'm going to look them up in my initial untransformed count data, I have to change them back..   
names(top.sp.glms.lvm.zostera.1) <- names(top.sp.glms.lvm.zostera.1) %>% 
  str_replace(pattern = "\\.", replacement = " ")

top.sp.glms.lvm.zostera.1
```

Try to plot these top contributing species - for whatever that's worth, because 50 species on a plot is still a monstrosity.  

```{r plot_relative_taxon_contrib_glms_lvm_zostera_1}
## get the species and their abundances from the original count data, and transform them to long format
(abnd.top.sp.glms.lvm.zostera.1 <- zoo.abnd.zostera %>% 
   select(station, names(top.sp.glms.lvm.zostera.1)) %>% 
   gather(key = "species", value = "count", -station) %>% 
   ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
   mutate(species = factor(species, levels = rev(names(top.sp.glms.lvm.zostera.1)))) %>% 
   mutate(group = factor(case_when(station %in% c("Poda", "Otmanli") ~ 1, 
                                   station == "Vromos" ~ 2, 
                                   station %in% c("Gradina", "Ropotamo") ~ 3))) ## add the groups to the long df 
)


(plot.top.sp.glms.lvm.zostera.1 <- plot_top_n(abnd.top.sp.glms.lvm.zostera.1,
                                         mapping = aes(x = species, y = log_y_min(count), colour = group),
                                         labs.legend = paste0("group", as.character(levels(abnd.top.sp.glms.lvm.zostera.1$group))),
                                         lab.y = "Abundance (log(y/min + 1))",
                                         palette = "Set2"
                                        ) +
    theme(legend.position = "top", legend.title = element_blank())

)
```

Well this is a nightmarish plot, but more tolerable than the one for the sand stations - there are less species here, so at least it's readable..   

Extract the top-contributing species to each cluster (this same nightmare above, but as a table). This chunk is STILL hopelessly ugly and clumsy.  
```{r table_relative_taxon_contrib_glms_lvm_zostera_1}
top.sp.abnd.glms.lvm.zostera.1 <- lapply(names(glms.lvm.zostera.1.summary$aliased), function(x) top_sp_glms_table(glms.lvm.zostera.1.summary, x, p = 0.05)) 

## fix species names (remove dot) 
top.sp.abnd.glms.lvm.zostera.1 <- lapply(top.sp.abnd.glms.lvm.zostera.1, function(x) x %>% mutate(species = str_replace(species, pattern = "\\.", replacement = " ")))

## rename columns (= group names) - right now they are something like "lvm.clusters.zostera2" etc.
top.sp.abnd.glms.lvm.zostera.1 <- lapply(top.sp.abnd.glms.lvm.zostera.1, function(x) x %>% rename_at(vars(contains("lvm.clusters.zostera.1")), list(~str_replace_all(., pattern = "lvm.clusters.zostera.1", "group_"))))

top.sp.abnd.glms.lvm.zostera.1 <- lapply(top.sp.abnd.glms.lvm.zostera.1, function(x) x %>% rename_at(vars(contains("Intercept")), list(~str_replace_all(., pattern = "\\(Intercept\\)", "group_1"))))


## pull the abundances from the original count df and add to the summary glm tables 
## make a long df of abundances & add clusters  
zoo.abnd.zostera.long.1 <- zoo.abnd.zostera %>%
  select(-c(month:replicate)) %>%
  gather(key = "species", value = "count", -station) %>% 
  mutate(group = case_when(station %in% c("Poda", "Otmanli") ~ 1, 
                           station == "Vromos" ~ 2, 
                           station %in% c("Gradina", "Ropotamo") ~ 3)
         )

## sum sp abundances by group; nest by group
zoo.abnd.zostera.long.1.smry <- zoo.abnd.zostera.long.1 %>% 
  group_by(species, group) %>% 
  summarise(total_count = sum(count)) %>% 
  group_by(group) %>%
  nest()

## add the counts to the group dfs - wow that's an ugly, ugly hack. Wish I had more time to write this up properly.. 
top.sp.abnd.glms.lvm.zostera.1 <- map2(top.sp.abnd.glms.lvm.zostera.1, zoo.abnd.zostera.long.1.smry %>% pull(group), ~left_join(.x, zoo.abnd.zostera.long.1.smry %>% filter(group == .y) %>% unnest(), by = "species"))

## since these are sum counts over all the replicates (that's why the monstrous numbers), average them to be mean counts per group. NB different groups consist of different numbers of replicates, b.c. some groups consist of more than one station
(top.sp.abnd.glms.lvm.zostera.1 <- map2(top.sp.abnd.glms.lvm.zostera.1, c(16, 4, 12), function(x, y) x %>% mutate(mean_count = total_count/y))
)
```

In this case, the model shows which species exhibit a reaction based on the chosen groups - in other words, which species are more likely to be more/less abundant in each group.  
I have to say, in the case of the seagrasses and case 1 clusters, there are much fewer species that exhibit a significant response - around 10 for each group.     
The LRs are lower for groups 2 and 3 - not sure if this means anything, but for group 1 they are much much higher..   
For **group 1** (= Z1-Z2), the species/taxa with significantly **higher abundance** are: Bittium reticulatum, Capitella minima, Oligochaeta, H. filiformis, Polydora ciliata, Prionospio cirrifera, R. membranacea, A. alba, A.diadema, M. acherusicum; and the only one with a significantly **lower abundance** - Chamelea gallina.   
For **group 2** (= Z3), the species with **higher abundance** are: M. acherusicum, S. filicornis, A.dadema. The species with **lower abundance** are: B. reticulatum, A. alba, Oligochaeta, S. clavata, P. ciliata, P. cirrifera, H. filiformis.  
For **group 3** (= Z4-Z5), the species with **higher abundance** are: Cumella limicola, Apseudopsis ostroumovi, Capitella capitata, Mytilaster lineatus, Loripes orbiculatus; less so, but still present - C. gallina, S. clavata. The species with **lower abundance** are: Abra alba, Melinna palmata (totally absent).  


I'll test each station as its own group, too (as I did before, with the classical multivariate methods) - I'm not sure how much I can trust this grouping (in particular group 3 is a bit far-fetched, if you ask me..).  


**LVM clusters - case 2**
Check the model assumptions.  
```{r check_mean_variance_lvm_zostera_2}
plot(manyglm(zoo.mvabnd.zostera ~ lvm.clusters.zostera.2, family = "negative.binomial"))

meanvar.plot(zoo.mvabnd.zostera ~ lvm.clusters.zostera.2, table = TRUE)
```

It's not perfect, but it's not too terrible either. I think it's a little worse than the case 1 fit.  

2. Assumed relationship between mean abundance and environmental variables - link function and formula.

Everything looks more or less fine; fit the model. 
```{r fit_glms_lvm_zostera_2}
glms.lvm.zostera.2 <- manyglm(zoo.mvabnd.zostera ~ lvm.clusters.zostera.2, 
                              family = "negative.binomial")

```

Explore the fit (residuals, diagnostic plots, etc.).  
```{r explore_glms_lvm_zostera_2}
## residuals vs fitted values
plot(glms.lvm.zostera.2)

## all traditional (g)lm diagnostic plots
plot.manyglm(glms.lvm.zostera.2, which = 1:3)
```

Save the model!  
```{r save_glms_lvm_zostera_2}
write_rds(glms.lvm.zostera.2, 
          here(save.dir, "glms_lvm_zostera_2.RDS"))
```

Save the model diagnostic plots - only for this one, since - spoiler alert! - I'm going with it in the end; it's marginally better than the other two options.   
```{r save_diagn_plots_glms_lvm_zostera_2}
png(here(figures.dir, "diagnostic_glms_lvm_zostera_2.png"), width = 25, height = 20, units = "cm", res = 300)
plot.manyglm(glms.lvm.zostera.2, which = 1:3)
dev.off()
```


Let's see the model summary (NB takes a LOT of time if there are many resamplings!).  
```{r summary_glms_lvm_zostera_2}
(glms.lvm.zostera.2.summary <- summary(glms.lvm.zostera.2, 
                                       test = "LR", p.uni = "adjusted",
                                       nBoot = 999, ## limit the number of permutations if you just want to check it out
                                       show.time = "all")
)
```

The factor is highly significant according to the models.  
 
Again, save the summary for safekeeping, but also run an anova.  
```{r save_summary_glms_lvm_zostera_2}
write_rds(glms.lvm.zostera.2.summary, 
          here(save.dir, "glms_lvm_zostera_2_summary.RDS"))
```

Run the anova on the model. 
```{r anova_glms_lvm_zostera_2}
(glms.lvm.zostera.2.aov <- anova.manyglm(glms.lvm.zostera.2, 
                                         test = "LR", p.uni = "adjusted", 
                                         nBoot = 999, ## limit the number of permutations for a shorter run time   
                                         pairwise.comp = ~lvm.clusters.zostera.2, ## check the pairwise comparison between clusters
                                         show.time = "all") 
)
```

Again, these groups are sufficiently different from one another.. No clue here. 

Save the ANOVA, too.  
```{r save_anova_glms_lvm_zostera_2}
write_rds(glms.lvm.zostera.2.aov, 
          here(save.dir, "glms_lvm_zostera_2_anova.RDS"))
```

NOW let's get the taxa with the highest contributions to the tested pattern.  
```{r relative_taxon_contrib_glms_lvm_zostera_2}
## get the top contributing species for the initial zostera GLMs 
(top.sp.glms.lvm.zostera.2 <- top_n_sp_glm(glms.lvm.zostera.2.aov, tot.dev.expl = 0.75)
)

## unfortunately, mvabund likes to rename my species when converting the data to matrix (no spaces in names), and since I'm going to look them up in my initial untransformed count data, I have to change them back..   
names(top.sp.glms.lvm.zostera.2) <- names(top.sp.glms.lvm.zostera.2) %>% 
  str_replace(pattern = "\\.", replacement = " ")

top.sp.glms.lvm.zostera.2
```

Try to plot these top contributing species - for whatever that's worth, because 50 species on a plot is still a monstrosity.  

```{r plot_relative_taxon_contrib_glms_lvm_zostera_2}
## get the species and their abundances from the original count data, and transform them to long format
(abnd.top.sp.glms.lvm.zostera.2 <- zoo.abnd.zostera %>% 
   select(station, names(top.sp.glms.lvm.zostera.2)) %>% 
   gather(key = "species", value = "count", -station) %>% 
   ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
   mutate(species = factor(species, levels = rev(names(top.sp.glms.lvm.zostera.2)))) %>% 
   mutate(group = factor(case_when(station == "Poda" ~ 1,
                                   station == "Otmanli" ~ 2,
                                   station == "Vromos" ~ 3, 
                                   station == "Gradina" ~ 4, 
                                   station == "Ropotamo" ~ 5)))
)


(plot.top.sp.glms.lvm.zostera.2 <- plot_top_n(abnd.top.sp.glms.lvm.zostera.2,
                                              mapping = aes(x = species, y = log_y_min(count), colour = group),
                                              labs.legend = paste0("group", as.character(levels(abnd.top.sp.glms.lvm.zostera.2$group))),
                                              lab.y = "Abundance (log(y/min + 1))",
                                              palette = "Set2"
                                        ) +
    theme(legend.position = "top", legend.title = element_blank())

)
```


Extract the top-contributing species to each cluster (this same nightmare above, but as a table). This chunk is STILL hopelessly ugly and clumsy.  
```{r table_relative_taxon_contrib_glms_lvm_zostera_2}
top.sp.abnd.glms.lvm.zostera.2 <- lapply(names(glms.lvm.zostera.2.summary$aliased), function(x) top_sp_glms_table(glms.lvm.zostera.2.summary, x, p = 0.05)) 

## fix species names (remove dot) 
top.sp.abnd.glms.lvm.zostera.2 <- lapply(top.sp.abnd.glms.lvm.zostera.2, function(x) x %>% mutate(species = str_replace(species, pattern = "\\.", replacement = " ")))

## rename columns (= group names) - right now they are something like "lvm.clusters.zostera2" etc.
top.sp.abnd.glms.lvm.zostera.2 <- lapply(top.sp.abnd.glms.lvm.zostera.2, function(x) x %>% rename_at(vars(contains("lvm.clusters.zostera.2")), list(~str_replace_all(., pattern = "lvm.clusters.zostera.2", "group_"))))

top.sp.abnd.glms.lvm.zostera.2 <- lapply(top.sp.abnd.glms.lvm.zostera.2, function(x) x %>% rename_at(vars(contains("Intercept")), list(~str_replace_all(., pattern = "\\(Intercept\\)", "group_1"))))


## pull the abundances from the original count df and add to the summary glm tables 
## make a long df of abundances & add clusters  
zoo.abnd.zostera.long.2 <- zoo.abnd.zostera %>%
  select(-c(month:replicate)) %>%
  gather(key = "species", value = "count", -station) %>% 
  mutate(group = case_when(station == "Poda" ~ 1,
                           station == "Otmanli" ~ 2, 
                           station == "Vromos" ~ 3, 
                           station == "Gradina" ~ 4, 
                           station == "Ropotamo" ~ 5)
         )

## sum sp abundances by group; nest by group
zoo.abnd.zostera.long.2.smry <- zoo.abnd.zostera.long.2 %>% 
  group_by(species, group) %>% 
  summarise(total_count = sum(count)) %>% 
  group_by(group) %>%
  nest()

## add the counts to the group dfs - wow that's an ugly, ugly hack. Wish I had more time to write this up properly.. 
top.sp.abnd.glms.lvm.zostera.2 <- map2(top.sp.abnd.glms.lvm.zostera.2, zoo.abnd.zostera.long.2.smry %>% pull(group), ~left_join(.x, zoo.abnd.zostera.long.2.smry %>% filter(group == .y) %>% unnest(), by = "species"))

## since these are sum counts over all the replicates (that's why the monstrous numbers), average them to be mean counts per group. NB different groups consist of different numbers of replicates, b.c. some groups consist of more than one station
(top.sp.abnd.glms.lvm.zostera.2 <- map2(top.sp.abnd.glms.lvm.zostera.2, c(8, 8, 4, 8, 4), function(x, y) x %>% mutate(mean_count = total_count/y))
)
```

In the case of the seagrasses and case 2 clusters (= stations), the picture is still more unclear.. I suppose this is in no small part because of the differences 2013-14 - very marked for Poda and Otmanli. I suspect the stations changed in these two years (we were looking for Z. noltii in 2014 in particular) - but still, there is much variability. In the future, it's probably going to be worth it to have more stations in a meadow, if we really want to have an idea of the communities there, and their variability.  
The LRs seem to be a bit lower for groups 2, 4, maybe 5 too - still not sure if you can use that as a significance measure.  
For now, in **group 1** (= Z1), it's hard to pick some characteristic species - because of the variability between 2013-2014, no doubt. The species/taxa with significantly **higher abundance** are: Bittium reticulatum, Capitella minima, Polydora ciliata, Prionosprio cirrifera (+ others, medium abundance); and the ones with a significantly **lower abundance** - or even absent - C. gallina, A. ostroumovi, S. clavata, C. limicola, C. costulata, S. hystrix, S. gracilis, T. pullus.   
For **group 2** (= Z2), the species with **higher abundance** - which is not really all that high; this group is also loose, hard to distinguish from group 1 - are: S. gracilis, M. lineatus, P. ciliata. The only species with **lower abundance** - in fact 0 - is Alitta succinea.  
For **group 3** (= Z3), the species with **higher abundance** are: M. acherusicum, S. filicornis, A. diadema. The species with **lower abundance** (or 0) are: B. reticulatum, P. ciliata, P. cirrifera, A. alba, A. succinea, S. clavata, Oligochaeta, A. improvisus.  
For **group 4** (= Z4), the species with **higher abundance** are: M. lineatus (very much so); C. limicola, P. kefersteini, C. gallina, C. capitata. The species with **lower abundance** (or 0) are: P. ciliata, P. cirrifera, A. succinea, A. improvisus, A. alba.  
For **group 5** (= Z5), the species with **higher abundance** are: A. ostroumovi, C. capitata, Oligochaeta. The species with **lower abundance** (or 0) are: R. splendida, T. pullus.  


**LVM clusters - case 3**
Last try: group 1 = Z1-Z2, group 2 = Z3, group 3 = Z4, group 4 = Z5.  
Check the model assumptions.  
```{r check_mean_variance_lvm_zostera_3}
plot(manyglm(zoo.mvabnd.zostera ~ lvm.clusters.zostera.3, family = "negative.binomial"))

meanvar.plot(zoo.mvabnd.zostera ~ lvm.clusters.zostera.3, table = TRUE)
```

More or less the same as case 2 before it. 

2. Assumed relationship between mean abundance and environmental variables - link function and formula.

Everything looks more or less fine; fit the model. 
```{r fit_glms_lvm_zostera_3}
glms.lvm.zostera.3 <- manyglm(zoo.mvabnd.zostera ~ lvm.clusters.zostera.3, 
                              family = "negative.binomial")

```

Explore the fit (residuals, diagnostic plots, etc.).  
```{r explore_glms_lvm_zostera_3}
## residuals vs fitted values
plot(glms.lvm.zostera.3)

## all traditional (g)lm diagnostic plots
plot.manyglm(glms.lvm.zostera.3, which = 1:3)
```

Save the model!  
```{r save_glms_lvm_zostera_3}
write_rds(glms.lvm.zostera.3, 
          here(save.dir, "glms_lvm_zostera_3.RDS"))
```


Let's see the model summary (NB takes a LOT of time if there are many resamplings!).  
```{r summary_glms_lvm_zostera_3}
(glms.lvm.zostera.3.summary <- summary(glms.lvm.zostera.3, 
                                       test = "LR", p.uni = "adjusted",
                                       nBoot = 999, ## limit the number of permutations if you just want to check it out
                                       show.time = "all")
)
```

The factor is highly significant according to the models.  
 
Again, save the summary for safekeeping, but also run an anova.  
```{r save_summary_glms_lvm_zostera_3}
write_rds(glms.lvm.zostera.3.summary, 
          here(save.dir, "glms_lvm_zostera_3_summary.RDS"))
```

Run the anova on the model. 
```{r anova_glms_lvm_zostera_3}
(glms.lvm.zostera.3.aov <- anova.manyglm(glms.lvm.zostera.3, 
                                         test = "LR", p.uni = "adjusted", 
                                         nBoot = 999, ## limit the number of permutations for a shorter run time   
                                         pairwise.comp = ~lvm.clusters.zostera.3, ## check the pairwise comparisons between clusters
                                         show.time = "all") 
)
```

According to the pairwise comparison, the case 3 clusters are significantly different from one another.. apparently sufficiently so.  

Save the ANOVA, too.  
```{r save_anova_glms_lvm_zostera_3}
write_rds(glms.lvm.zostera.3.aov, 
          here(save.dir, "glms_lvm_zostera_3_anova.RDS"))
```

NOW let's get the taxa with the highest contributions to the tested pattern.  
```{r relative_taxon_contrib_glms_lvm_zostera_3}
## get the top contributing species for the initial zostera GLMs 
(top.sp.glms.lvm.zostera.3 <- top_n_sp_glm(glms.lvm.zostera.3.aov, tot.dev.expl = 0.75)
)

## unfortunately, mvabund likes to rename my species when converting the data to matrix (no spaces in names), and since I'm going to look them up in my initial untransformed count data, I have to change them back..   
names(top.sp.glms.lvm.zostera.3) <- names(top.sp.glms.lvm.zostera.3) %>% 
  str_replace(pattern = "\\.", replacement = " ")

top.sp.glms.lvm.zostera.3
```

Try to plot these top contributing species - for whatever that's worth, because 50 species on a plot is still a monstrosity.  

```{r plot_relative_taxon_contrib_glms_lvm_zostera_3}
## get the species and their abundances from the original count data, and transform them to long format
(abnd.top.sp.glms.lvm.zostera.3 <- zoo.abnd.zostera %>% 
   select(station, names(top.sp.glms.lvm.zostera.3)) %>% 
   gather(key = "species", value = "count", -station) %>% 
   ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
   mutate(species = factor(species, levels = rev(names(top.sp.glms.lvm.zostera.3)))) %>% 
   mutate(group = factor(case_when(station %in% c("Poda", "Otmanli") ~ 1,
                                   station == "Vromos" ~ 2, 
                                   station == "Gradina" ~ 3, 
                                   station == "Ropotamo" ~ 4)) ## add the groups
          )
)

(plot.top.sp.glms.lvm.zostera.3 <- plot_top_n(abnd.top.sp.glms.lvm.zostera.3,
                                              mapping = aes(x = species, y = log_y_min(count), colour = group),
                                              labs.legend = paste0("group", as.character(levels(abnd.top.sp.glms.lvm.zostera.3$group))),
                                              lab.y = "Abundance (log(y/min + 1))",
                                              palette = "Set2"
                                        ) +
    theme(legend.position = "top", legend.title = element_blank())

)
```


Extract the top-contributing species to each cluster (this same nightmare above, but as a table). This chunk is STILL hopelessly ugly and clumsy.  
```{r table_relative_taxon_contrib_glms_lvm_zostera_3}
top.sp.abnd.glms.lvm.zostera.3 <- lapply(names(glms.lvm.zostera.3.summary$aliased), function(x) top_sp_glms_table(glms.lvm.zostera.3.summary, x, p = 0.05)) 

## fix species names (remove dot) 
top.sp.abnd.glms.lvm.zostera.3 <- lapply(top.sp.abnd.glms.lvm.zostera.3, function(x) x %>% mutate(species = str_replace(species, pattern = "\\.", replacement = " ")))

## rename columns (= group names) - right now they are something like "lvm.clusters.zostera3" etc.
top.sp.abnd.glms.lvm.zostera.3 <- lapply(top.sp.abnd.glms.lvm.zostera.3, function(x) x %>% rename_at(vars(contains("lvm.clusters.zostera.3")), list(~str_replace_all(., pattern = "lvm.clusters.zostera.3", "group_"))))

top.sp.abnd.glms.lvm.zostera.3 <- lapply(top.sp.abnd.glms.lvm.zostera.3, function(x) x %>% rename_at(vars(contains("Intercept")), list(~str_replace_all(., pattern = "\\(Intercept\\)", "group_1"))))


## pull the abundances from the original count df and add to the summary glm tables 
## make a long df of abundances & add clusters  
zoo.abnd.zostera.long.3 <- zoo.abnd.zostera %>%
  select(-c(month:replicate)) %>%
  gather(key = "species", value = "count", -station) %>% 
  mutate(group = case_when(station %in% c("Poda", "Otmanli") ~ 1,
                           station == "Vromos" ~ 2, 
                           station == "Gradina" ~ 3, 
                           station == "Ropotamo" ~ 4)
         )

## sum sp abundances by group; nest by group
zoo.abnd.zostera.long.3.smry <- zoo.abnd.zostera.long.3 %>% 
  group_by(species, group) %>% 
  summarise(total_count = sum(count)) %>% 
  group_by(group) %>%
  nest()

## add the counts to the group dfs - wow that's an ugly, ugly hack. Wish I had more time to write this up properly.. 
top.sp.abnd.glms.lvm.zostera.3 <- map2(top.sp.abnd.glms.lvm.zostera.3, zoo.abnd.zostera.long.3.smry %>% pull(group), ~left_join(.x, zoo.abnd.zostera.long.3.smry %>% filter(group == .y) %>% unnest(), by = "species"))

## since these are sum counts over all the replicates (that's why the monstrous numbers), average them to be mean counts per group. NB different groups consist of different numbers of replicates, b.c. some groups consist of more than one station
(top.sp.abnd.glms.lvm.zostera.3 <- map2(top.sp.abnd.glms.lvm.zostera.3, c(16, 4, 8, 4), function(x, y) x %>% mutate(mean_count = total_count/y))
)
```

In the case of the seagrasses and case 3 clusters, the picture is still more confusing..  
The LRs seem to be a bit lower for groups 2 and 3, maybe 4 too - still not sure if you can use that as a significance measure.  
For now, in **group 1** (= Z1-Z2), the species/taxa with significantly **higher abundance** are: Bittium reticulatum, Capitella minima, Oligochaeta, Heteromastus filiformis, Polydora ciliata, Prionosprio cirrifera, Rissoa membranacea, Abra alba, Ampelisca diadema (+ others, medium abundance); and the ones with a significantly **lower abundance** - or even absent -  S. clavata,  A. ostroumovi, C. gallina, T. pullus.   
There are more species singled out for this cluster, probably because of the variability between the two years of sampling.  
For **group 2** (= Z3), the species with **higher abundance** are: M. acherusicum, S. filicornis, A. diadema. The species with **lower abundance** - in fact 0 - are B. reticulatum, P. cirrifera, S. clavata, A. alba, P. ciliata, oligochaetes, H. filiformis, R. splendida.  
For **group 3** (= Z4), the species with **higher abundance** are: M. lineatus, less so - C. limicola, L. orbiculatus, P. kefersteini, C. capitata, etc. The species with **lower abundance** (or 0) are: P. cirrifera, P. ciliata, A. alba, etc.  
For **group 4** (= Z5), the species with **higher abundance** are: A. ostoumovi, C. capitata, oligochaetes (very abundant, but with a small LR - nice!). The species with **lower abundance** (or 0) are: R. splendida, S. clavata, C. limicola.  


**All in all, I think that group 1 (Poda + Otmanli) holds, and so does group 2 (Vromos). The question is whether to separate Gradina and Ropotamo into 2 groups, or if they make more sense together. Ropotamo is characterized by a very high number of oligochaetes, while Gradina's most distinguishing characteristic is the high number of M. lineatus - mostly very small ones, attached to the rhizomes, close to the sediment surface I presume. Both stations have C. limicola in medium abundance, a species that is not present anywhere else (is it?).** 


Try to compare the three models.. 
```{r compare_glms_lvm_zostera_1}
(glms.lvm.zostera.comp <- anova(glms.lvm.zostera.1,
                                glms.lvm.zostera.2, 
                                glms.lvm.zostera.3, 
                                p.uni = "adjusted")
)

```

Well this is tough to interpret.. Multivariate test table's Dev is decrement from upper model, so each p-value indicates the difference between the model and upper one is statistically significant... But no info on which model represents the species matrix best.  

I'll go with the model with the lowest AIC, since there is no other objective criterion to go with.. This happens to be model 2 (groups = stations). Exactly the same result as from the classical methods.  
```{r compare_glms_lvm_zostera_2}
glms.lvm.zostera.1$AICsum
glms.lvm.zostera.2$AICsum
glms.lvm.zostera.3$AICsum
```


###### **manyGLM by environmental parameters**  
Now, let's try to see a different thing - which environmental parameters best describe the species response.  
I'm going to use the PCA-filtered environmental data - it's still going to be a slog, with 7 potential predictors..  
First, construct the formula for the model - will do it separately in case I need to update it later, etc.  
NB there is year here - I want to try with it first!! And I don't want the Secchi depth - it has NAs for Vromos.  
```{r formula_env_manyglm_full_zostera}
(formula.env.glms.zostera <- formula(paste("zoo.mvabnd.zostera ~",
                                           paste(env.zostera %>% select(-c(station, secchi)) %>% names(), collapse = "+")))
)
```

Fit the GLMs - including all environmental parameters - to the zostera abundance data. 
```{r fit_glms_env_full_zostera}
env.glms.zostera <- manyglm(formula.env.glms.zostera,
                            data = env.zostera,
                            family = "negative.binomial")

```

Explore the fit (residuals, diagnostic plots, etc.).  
```{r explore_glms_env_full_zostera}
## residuals vs fitted values
plot(env.glms.zostera)

## all traditional (g)lm diagnostic plots
plot.manyglm(env.glms.zostera, which = 1:3)
```

Well, it's good enough if you ask me (still the kinda strange "line" at lin.pred = -6; otherwise residuals are random enough).  

Save the model!  
```{r save_glms_env_full_zostera}
write_rds(env.glms.zostera, 
          here(save.dir, "glms_env_zostera.RDS"))
```

Before going off and running an ANOVA to check which predictors best explain the species abundance patterns, I'll try to reduce the model a little - it might even improve the fit, not to mention the run time.  
```{r select_top_glm_env_zostera}
## selection function defined in the sand section 
top.env.glm.red.zostera <- evaluate_glms_env(env.glms.zostera)

```

Check its fit. 
```{r explore_top_glm_env_red_zostera}
## residuals vs fitted values
plot(top.env.glm.red.zostera)

## all traditional (g)lm diagnostic plots
plot.manyglm(top.env.glm.red.zostera, which = 1:3)
```

I think it's fine; might even be better than the full model.. 
Save it, too. 
```{r save_top_glm_env_red_zostera}
write_rds(top.env.glm.red.zostera, 
          here(save.dir, "glms_top_env_red_zostera.RDS"))
```

Save the diagnostic plots.  
```{r save_diagn_plots_top_glm_env_red_zostera}
png(here(figures.dir, "diagnostic_top_glm_env_red_zostera.png"), width = 25, height = 20, units = "cm", res = 300)
plot.manyglm(top.env.glm.red.zostera, which = 1:3)
dev.off()
```

Run ANOVA on this model.
```{r anova_top_glm_env_red_zostera}
(top.env.glm.red.zostera.aov <- anova.manyglm(top.env.glm.red.zostera,
                                              test = "LR", p.uni = "adjusted", 
                                              nBoot = 999, ## limit the number of permutations for a shorter run time   
                                              show.time = "all") 
)
```

Nice, all terms are significant now! 
Again, as with the sand samples, there is one eutrophication term + one sediment composition + seagrass parameters. Seems reasonable enough.  

Save this ANOVA (takes too long to run anew).  
```{r save_anova_top_glm_env_red_zostera}
write_rds(top.env.glm.red.zostera.aov, 
          here(save.dir, "glms_top_env_red_zostera_anova.RDS"))
```


Get the taxa with the highest contributions to the tested pattern (here - species most affected by changes in water/environmental quality parameters).  
```{r relative_taxon_contrib_top_glm_env_red_zostera}
## get the top contributing species for the environmental parameter zostera GLMs 
(top.sp.glms.env.red.zostera <- top_n_sp_glm(top.env.glm.red.zostera.aov, tot.dev.expl = 0.75)
)

## unfortunately, mvabund likes to rename my species when converting the data to matrix (no spaces in names), and since I'm going to look them up in my initial untransformed count data, I have to change them back..   DON'T BE IN A HURRY TO DO THAT IF YOU WANT TO SUBSET THE ORIGINAL MATRIX BEFORE RUNNING TRAITGLM 
names(top.sp.glms.env.red.zostera) <- names(top.sp.glms.env.red.zostera) %>% 
  str_replace(pattern = "\\.", replacement = " ")

```

I'm going to plot these top contributing species, but I'm not using the plot. At least this time it's more manageable, but still not presentable enough.. 

```{r plot_relative_taxon_contrib_top_glm_env_red_zostera}
## get the species and their abundances from the original count data, and transform them to long format
(abnd.top.sp.glms.env.red.zostera <- zoo.abnd.zostera %>% 
   select(station, names(top.sp.glms.env.red.zostera)) %>% 
   gather(key = "species", value = "count", -station) %>% 
   ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
   mutate(species = factor(species, levels = rev(names(top.sp.glms.env.red.zostera)))) %>% 
   ## add clusters from LVM as a column
   mutate(group = case_when(station == "Poda" ~ 1, 
                            station == "Otmanli" ~ 2, 
                            station == "Vromos" ~ 3, 
                            station == "Gradina" ~ 4, 
                            station == "Ropotamo" ~ 5))
)


(plot.top.sp.glms.env.red.zostera <- plot_top_n(abnd.top.sp.glms.env.red.zostera,
                                         mapping = aes(x = species, y = log_y_min(count), colour = factor(group)),
                                         labs.legend = unique(abnd.top.sp.glms.env.red.zostera$group),
                                         lab.y = "Abundance (log(y/min + 1))",
                                         palette = "Set2"
                                        ) + 
    theme(legend.position = "top")

)
```


Make a plot with less species (~10-15) for the defense presentation - in the end, it's more illustrative and easier to understand. Again, this still means multiple plots - for each environmental factor in the model.  
```{r extract_top10_taxa_glm_env_red_zostera}
## since the top contributing taxa are already extracted, I'll just get the original abundances of the top 10 (or 15) in the vector  
## get the selected species and their abundances from the original count data, and transform them to long format
abnd.top10.sp.glms.env.red.zostera <- zoo.abnd.zostera %>% 
  select(station, names(top.sp.glms.env.red.zostera[1:10])) %>% 
  gather(key = "species", value = "count", -station) %>% 
  ## turn species into a factor, or you'll be very very sorry later, when they're out of order on the plot. NB need to be in REVERSE order, because ggplot plots from bottom to top, and I want the top-contributing species on top. 
  mutate(species = factor(species, levels = rev(names(top.sp.glms.env.red.zostera)))) 


## add the significant environmental parameters from the model
(abnd.top10.sp.glms.env.red.zostera <- left_join(abnd.top10.sp.glms.env.red.zostera, 
                                              env.zostera %>% select(station, Ntotal, sand, shoot_count, ag_biomass_wet, bg_biomass_wet), 
                                              by = "station") 
    
)
```

Now make a plot of species abundances, coloring them by environmental factor values (4 plots in total).  
```{r plot_top10_taxa_glm_env_red_zostera_by_param}
(plots.list.top10.taxa.glm.env.red.zostera <- lapply(c("Ntotal", "sand", "shoot_count", "ag_biomass_wet", "bg_biomass_wet"), 
                                                     function (i) {
                                                ggplot(abnd.top10.sp.glms.env.red.zostera,
                                                       aes_(x = ~species, y = ~log_y_min(count), colour = as.name(i))) +
                                                        # scale_colour_viridis(option = "viridis") +
                                                        geom_point() +
                                                        coord_flip() +
                                                        labs(x = "", y = "Abundance (log(y/min + 1))")
                                                      }
                                                ) 
)

## set the names of the plots in the list - will be easier to save them in one go later (less fiddling with constructing file names)
names(plots.list.top10.taxa.glm.env.red.zostera) <- c("Ntotal", "sand", "shoot_count", "ag_biomass_wet", "bg_biomass_wet")

```

Save these plots.. 
```{r save_plots_top10_taxa_glm_env_red_zostera_by_param}
map2(names(plots.list.top10.taxa.glm.env.red.zostera),
     plots.list.top10.taxa.glm.env.red.zostera, 
     function(a, b) {
       ggsave(filename = here(figures.dir, paste0("top10_taxa_glm_env_red_zostera_", a, ".png")),
              b, 
              width = 15, height = 10, units = "cm", dpi = 300)
       })
```


Extract the taxon information (univariate tests) from the model ANOVA to present as a table (probably better than this plot, although it's informative).  
```{r table_relative_taxon_contrib_top_glm_env_red_zostera}
## extract the univariate test coefficients (LR) from the environmental model ANOVA. NB keep the row names when converting the matrix to tibble! 
table.top.sp.glms.env.red.zostera <- as_tibble(top.env.glm.red.zostera.aov$uni.test, rownames = "var")

## fix the species names - remove first dor  
names(table.top.sp.glms.env.red.zostera) <- names(table.top.sp.glms.env.red.zostera) %>% 
  str_replace(pattern = "\\.", replacement = " ")

## subset only the top species (explaining ~75% of the dataset variation)
table.top.sp.glms.env.red.zostera <- table.top.sp.glms.env.red.zostera %>% 
  select(var, names(top.sp.glms.env.red.zostera))

## transpose, because a table with 50 columns is just unreadable
(table.top.sp.glms.env.red.zostera <- table.top.sp.glms.env.red.zostera %>%
    gather(key = species, value = value, -var) %>% 
    spread(key = var, value = value) %>% 
    ## arrange as before (terms in the order they appear in the model, and by descending value of the LR for the first model term - here, Ntotal). Also get rid of the intercept (it's all-NA anyway).
    select(species, Ntotal, sand, shoot_count, ag_biomass_wet, bg_biomass_wet) %>%
    arrange(desc(Ntotal)) 
)
```

Save this to a file - will have to format it as a nice table by hand, unfortunately. 
```{r save_table_relative_taxon_contrib_top_glm_env_red_zostera}
write_csv(table.top.sp.glms.env.red.zostera, 
          here(save.dir, "taxa_contrib_glms_top_env_red_zostera.csv"))
```


Calculate the percentage contribution of each of these species to each of the model terms (Dev(term) = Sum-of-LR - sum of the LRs for the individual univariate species tests).. 
```{r table_prop_relative_taxon_contrib_top_glm_env_red_zostera}
## get the total deviance (Sum-of-LR) for each model term
(dev.terms.top.glms.env.zostera <- as_tibble(top.env.glm.red.zostera.aov$table, rownames = "var") %>%
   ## get rid of unnecessary variables (I only want the deviance value for each term) and intercept term 
   select(var, Dev) %>% 
   filter(var != "(Intercept)") %>% 
   ## transpose 
   gather(variable, value, -var) %>%
   spread(var, value) %>% 
   ## get rid of first column and rearrange columns to match table of deviances of univariate tests for species 
   select(-variable) %>% 
   select(Ntotal, sand, shoot_count, ag_biomass_wet, bg_biomass_wet)
)  

## calculate the proportion contribution of each species to each parameter deviance
prop.top.sp.glms.env.red.zostera <- map2_df(table.top.sp.glms.env.red.zostera %>% select(-species), 
                                            dev.terms.top.glms.env.zostera,
                                            ~.x/.y)

## add back the species 
(prop.top.sp.glms.env.red.zostera <- bind_cols(table.top.sp.glms.env.red.zostera %>% select(species), 
                                               prop.top.sp.glms.env.red.zostera)
)
```




I'll do the pseudo-traits analysis - fit single predictive model for all species at all sites, but w/o attempting to explain the different responses using traits - the species ID is used in place of a traits matrix), although I don't think it will amount to anything useful.   
NB only use the top species that exhibited a reaction in the environmental model fit (= the ones accounting for ~75% of the total variability), and only the significant predictors - to improve run times.   
```{r sp_response_top_glm_env_red_zostera}
sp.response.glms.env.red.zostera <- traitglm(L = mvabund(zoo.abnd.flt.zostera[, names(top.sp.glms.env.red.zostera)]), 
                                             R = as.matrix(env.zostera %>% select(Ntotal, sand, shoot_count, ag_biomass_wet, bg_biomass_wet)), 
                                             method = "manyglm")


sp.response.glms.env.red.zostera$fourth.corner


# plot this 
a.z <- max(abs(sp.response.glms.env.red.zostera$fourth.corner))
colort <- colorRampPalette(c("blue","white","red")) 
plot.spp.z <- lattice::levelplot(t(as.matrix(sp.response.glms.env.red.zostera$fourth.corner)), xlab = "Environmental Variables",
                     ylab = "Species", col.regions = colort(100), at = seq(-a.z, a.z, length = 100),
                     scales = list(x = list(rot = 45)))
print(plot.spp.z)
```

Here at least the directions are a little more coherent than the environmental parameters for the sand stations (seagrass biomasses more or less in the same direction, etc.). The below-ground biomass exerts more pronounced influence on the specific abundances - normal, since most of these are infauna.  

